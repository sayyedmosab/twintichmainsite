<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RubiksCubeExperience â€“ CDN</title>
  <style>
    :root { --bg:transparent; --panel:#0a0f1c; --text:#e5e7eb; --accent:#7c3aed; }
    html, body { height: 100%; margin: 0; background: transparent; color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; scrollbar-width: none; -ms-overflow-style: none; }
    html::-webkit-scrollbar, body::-webkit-scrollbar { display: none; }
    .wrap { position: relative; height: 100%; }
    .bg-video { position: fixed; inset: 0; width: 100vw; height: 100vh; object-fit: cover; z-index: 0; }
    .bg-tint { position: fixed; inset: 0; background: rgba(10,15,28,0.64); z-index: 0; }
.hero-row { display: none; }
.text-col { width: 450px; max-width: 640px; padding: 0 19px 0 60px; color: #ffffff; font-family: Poppins, sans-serif; position: sticky; top: 60px; }
.text-section { min-height: 590.4px; display: flex; align-items: flex-start; justify-content: flex-start; padding-top: 60px; }
.text-col h1 { margin: 20px 0 12px; font: 400 65px/76.1px "Allerta Stencil", sans-serif; color: #ffffff; text-shadow: 0 0 2px rgba(255,255,255,0.544), 0 0 12px rgba(76,201,255,0.531), 0 0 28px rgba(76,201,255,0.498), 0 0 56px rgba(30,144,255,0.476), 0 0 110px rgba(14,110,253,0.434); }
.hero-row section:nth-of-type(2) .text-col h1 { font: 400 40px/40px "Allerta Stencil", sans-serif; }
.hero-row section:nth-of-type(3) .text-col h1 { font: 400 40px/40px "Allerta Stencil", sans-serif; }
.hero-row section:nth-of-type(1) .text-col { width: 640px; }
.hero-row section:nth-of-type(1) .text-col h1 { font: 400 92px/91.1px "Allerta Stencil", sans-serif; color: #ffffff; text-shadow: 0 0 3px rgba(255,255,255,0.544), 0 0 18px rgba(76,201,255,0.544), 0 0 40px rgba(76,201,255,0.52), 0 0 84px rgba(30,144,255,0.488), 0 0 140px rgba(14,110,253,0.462); }
.hero-row section:nth-of-type(1) .text-col h2 { font-size: 27px; }
.text-col h2 { font-weight: 600; margin: 0 0 20px; text-transform: uppercase; letter-spacing: 1.30458px; font-size: 16px; color: rgba(37, 128, 250, 1); }
.text-col p  { font-weight: 300; margin: 0; font-size: clamp(0.95rem, 1.2vw, 1.25rem); line-height: 1.6; }
.hero-row section:nth-of-type(1) .text-col p { font-size: 18px; line-height: 24px; }
.sticky-canvas { position: fixed; top: 0; left: 33.333vw; width: 66.666vw; height: 100vh; overflow: hidden; background: transparent; z-index: 2; }
    #stage { background: transparent !important; }
    #stage { width: 100%; height: 100%; display:block; }
    .spacer { height: 18000px; } /* Scroll length to span all phases */
    .phase-pad { height: 0px; }
    .phase-overlay { position: fixed; inset: 0; z-index: 3; pointer-events: none; }
    .phase-overlay .overlay-inner { position: absolute; top: 60px; left: 0; font-family: Poppins, sans-serif; color: #ffffff; }
    .phase-text-block { position: absolute; top: 0; left: 0; width: 575px !important; max-width: none !important; padding: 0 19px 0 56px; box-sizing: content-box; opacity: 1; pointer-events: none; font-family: Poppins, sans-serif; color: #ffffff; transform: translateY(0); transition: none; z-index: 1; visibility: hidden; will-change: transform; }
    /* Match backup typography inside overlay */
    .phase-overlay .phase-text-block h1 { margin: 20px 0 12px; font: 400 65px/76.1px "Allerta Stencil", sans-serif; color: #ffffff; text-shadow: 0 0 2px rgba(255,255,255,0.544), 0 0 12px rgba(76,201,255,0.531), 0 0 28px rgba(76,201,255,0.498), 0 0 56px rgba(30,144,255,0.476), 0 0 110px rgba(14,110,253,0.434); }
    .phase-overlay .phase-text-block[data-key="intro-1"] h1 { font: 400 92px/91.1px "Allerta Stencil", sans-serif; color: #ffffff; text-shadow: 0 0 3px rgba(255,255,255,0.544), 0 0 18px rgba(76,201,255,0.544), 0 0 40px rgba(76,201,255,0.52), 0 0 84px rgba(30,144,255,0.488), 0 0 140px rgba(14,110,253,0.462); }
    .phase-overlay .phase-text-block[data-key="p89-future"] h1 { font: 400 92px/91.1px "Allerta Stencil", sans-serif; color: #ffffff; text-shadow: 0 0 3px rgba(255,255,255,0.544), 0 0 18px rgba(76,201,255,0.544), 0 0 40px rgba(76,201,255,0.52), 0 0 84px rgba(30,144,255,0.488), 0 0 140px rgba(14,110,253,0.462); }
    .phase-overlay .phase-text-block h2 { font-weight: 600; margin: 0 0 20px; text-transform: uppercase; letter-spacing: 1.30458px; font-size: 16px; color: rgba(37, 128, 250, 1); }
        .phase-overlay .phase-text-block:not([data-key="intro-1"]) h2 { font-size: 24px; font-weight: 700; color: rgba(37, 128, 250, 1); }
    .phase-overlay .phase-text-block[data-key="intro-1"] h2 { font-size: 28px; font-weight: 700; color: rgba(37, 128, 250, 1); }
    .phase-overlay .phase-text-block[data-key="p89-future"] h2 { font-size: 28px; font-weight: 700; color: rgba(37, 128, 250, 1); }
    .phase-overlay .phase-text-block p  { font-weight: 300; margin: 0; font-size: 18px; line-height: 24px; }
    .phase-overlay .phase-text-block[data-key="intro-1"] p { font-size: 18px; line-height: 24px; }
    .phase-overlay .phase-text-block[data-key="p89-future"] p { font-size: 18px; line-height: 24px; }
    .phase-text-block.active { z-index: 2; visibility: visible; }
    .phase-viewport { position: relative; overflow: visible; height: 600px; }
    @media (prefers-reduced-motion: reduce) { .phase-text-block { transition: none !important; transform: translateY(0) !important; } .phase-text-block.leaving { transform: translateY(0) !important; } }
    .phase-text-block.leaving { visibility: visible; }

    /* Overlay-specific typography and sizing */
    .phase-overlay .phase-text-block[data-key="intro-1"] { width: 640px !important; max-width: none !important; }
    .phase-overlay .phase-text-block[data-key="p89-future"] { width: 575px !important; max-width: none !important; }
    .phase-overlay .phase-text-block[data-key="intro-2"],
    .phase-overlay .phase-text-block[data-key="intro-3"],
    .phase-overlay .phase-text-block[data-key="p23-your-org"],
    .phase-overlay .phase-text-block[data-key="p4-hidden"],
    .phase-overlay .phase-text-block[data-key="p56-where"],
    .phase-overlay .phase-text-block[data-key="p7-two-years"] { width: 575px !important; max-width: none !important; }
        /* Ensure children use container width */
    .phase-text-block > h1, .phase-text-block > h2, .phase-text-block > p { display: block; max-width: 100%; }
    /* Ensure consistent top alignment between blocks */
    #phaseOverlay .phase-text-block h1:first-child { margin-top: 20px; }
        .phase-overlay .phase-text-block[data-key="intro-1"] h1 { font: 400 92px/91.1px "Allerta Stencil", sans-serif; color: #ffffff; text-shadow: 0 0 3px rgba(255,255,255,0.544), 0 0 18px rgba(76,201,255,0.544), 0 0 40px rgba(76,201,255,0.52), 0 0 84px rgba(30,144,255,0.488), 0 0 140px rgba(14,110,253,0.462); }
    .phase-overlay .phase-text-block[data-key="intro-1"] h2 { font-size: 28px; font-weight: 700; color: rgba(37, 128, 250, 1); }
    .phase-overlay .phase-text-block[data-key="intro-1"] p  { font-size: 18px; line-height: 24px; }
    
    /* Finale columns styling */
    .finale-columns {
      position: absolute;
      top: 60px;
      left: 0;
      width: 100vw;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 80px;
      font-family: Poppins, sans-serif;
      color: #ffffff;
      z-index: 10;
      will-change: transform;
    }
    
    .finale-left-column,
    .finale-right-column {
      width: 400px;
      padding: 30px;
      background: rgba(10, 15, 28, 0.8);
      border: 1px solid rgba(37, 128, 250, 0.3);
      border-radius: 12px;
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      text-align: center;
    }
    
    .finale-header {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      margin-bottom: 16px;
    }
    
    .finale-logo {
      width: 48px;
      height: 48px;
      object-fit: contain;
    }
    
    .finale-columns h1 {
      font: 400 48px/52px "Allerta Stencil", sans-serif;
      color: #ffffff;
      text-shadow: 0 0 2px rgba(255,255,255,0.544), 0 0 12px rgba(76,201,255,0.531), 0 0 28px rgba(76,201,255,0.498);
      margin: 0;
    }
    
    .finale-columns h2 {
      font-weight: 700;
      font-size: 20px;
      color: rgba(37, 128, 250, 1);
      text-transform: uppercase;
      letter-spacing: 1.2px;
      margin: 0 0 20px 0;
    }
    
    .finale-columns p {
      font-weight: 300;
      font-size: 16px;
      line-height: 22px;
      margin: 0 0 24px 0;
    }
    
    .finale-columns ul {
      list-style: none;
      padding: 0;
      margin: 0 0 32px 0;
    }
    
    .finale-columns li {
      font-size: 14px;
      line-height: 20px;
      padding: 8px 0;
      border-bottom: 1px solid rgba(37, 128, 250, 0.2);
      color: rgba(255, 255, 255, 0.8);
    }
    
    .finale-columns li:last-child {
      border-bottom: none;
    }
    
    .finale-enter-btn {
      background: linear-gradient(135deg, rgba(37, 128, 250, 1) 0%, rgba(76, 201, 255, 1) 100%);
      border: none;
      border-radius: 8px;
      color: #ffffff;
      font-family: Poppins, sans-serif;
      font-size: 16px;
      font-weight: 600;
      padding: 12px 32px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 16px rgba(37, 128, 250, 0.3);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .finale-enter-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 24px rgba(37, 128, 250, 0.4);
      background: linear-gradient(135deg, rgba(76, 201, 255, 1) 0%, rgba(37, 128, 250, 1) 100%);
    }
    
    .finale-enter-btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 8px rgba(37, 128, 250, 0.3);
    }
    
    header, footer { position: fixed; left: 0; right: 0; display:flex; align-items:center; justify-content:space-between; padding: 10px 14px; background: rgba(10,15,28,0.6); -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px); z-index: 5; border-bottom: 1px solid #111827; }
    header { top: 0; }
    footer { bottom: 0; border-top: 1px solid #111827; border-bottom: none; }
    .badge { font-size: 12px; padding: 6px 10px; border:1px solid #374151; background:#0f172a; border-radius: 999px; font-weight: 700; letter-spacing:0.02em; }
    .toolbar { display:flex; gap:8px; align-items:center; }
    .btn { appearance:none; border:1px solid #374151; background:#0f172a; color:var(--text); padding:6px 10px; border-radius:6px; cursor:pointer; font-weight:600; }
    .btn:hover { background:#111827; }
    .phase-indicator { position: fixed; right: 12px; top: 12px; z-index: 10; display:flex; gap:8px; align-items:center; }
    .phase-label { font-size: 12px; padding: 6px 10px; border:1px solid #374151; background:#0f172a; border-radius: 999px; font-weight: 700; }
    .mouse-label { display:none; font-size: 12px; padding: 6px 10px; border:1px solid #374151; background:#0f172a; border-radius: 999px; font-weight: 700; }
    .metrics { position: fixed; left: 12px; bottom: 12px; opacity: .8; font-size: 12px; }
    .coords-panel { position: fixed; right: 12px; top: 80px; width: 300px; max-height: calc(100vh - 160px); overflow: auto; background: rgba(0,0,0,0.5); -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px); border: 1px solid #374151; border-radius: 8px; padding: 8px 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 11px; line-height: 1.45; color: #e5e7eb; z-index: 9; }
    /* Hide UI overlays for clean animation */
    header, footer, .coords-panel, .phase-indicator, .metrics { display: none !important; }
  </style>

  <!-- map the baare specifier 'three' to the CDN module -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.180.0/build/three.module.js"
      }
    }
  </script>
  <!-- map the bare specifier 'three' to the CDN module -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.180.0/build/three.module.js"
      }
    }
  </script>
  <!-- Web fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Allerta+Stencil&family=Poppins:wght@300;600;800&display=swap" rel="stylesheet">
  <!-- GSAP for robust text animations -->
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
</head>
<body>
  <div class="wrap">
  <img class="bg-image" src="/images/HomeBackground.png" alt="Background" style="position:fixed; inset:0; width:100vw; height:100vh; object-fit:cover; z-index:0;" />
    <div class="bg-tint"></div>

    <!-- Phase-driven overlay text -->
    <div id="phaseOverlay" class="phase-overlay">
      <div class="overlay-inner">
        <div class="phase-text-block" data-key="intro-1">
          <h1>Transforming Strategy Execution</h1>
          <h2>COMPLEXITY AS AN ASSET</h2>
          <p>Most transformations fail because complexity overwhelms. We turned that complexity into an advantage - redefining planning, risks, and dashboards inside one integrated model. <br><b>Good news:</b> its not your fault, its complexity. <br><b>Bad news:</b> it is your fault if you don't explore the alternative.</p>
        </div>
        <div class="phase-text-block" data-key="intro-2">
          <h1>Imagine a Parallel Universe</h1>
          <h2>WHERE TRANSFORMATIONS<br>FLOW</h2>
          <p>Let us show you a week in that universe â€” A Week in the Life of a Transformation Team &lt;video link&gt;. Farfetched? Itâ€™s here. We built the MVP: a Net.js web app with a Supabase database and a Gemini Assistant, built on a five-year scenario dataset inspired by real transformation events.</p>
        </div>
        <div class="phase-text-block" data-key="intro-3">
          <h1>So How Did We Do It?</h1>
          <h2>THE RIGHT QUESTIONS FIRST</h2>
          <p>Before answers, you need the right questions. This journey begins by uncovering the questions that matter mostâ€”the ones that unlock how complexity really works.</p>
        </div>
        <div class="phase-text-block" data-key="p23-your-org">
          <h1>The Anatomy of an Organization</h1>
          <h2>WHAT MAKES AN ORGANIZATION?</h2>
          <p>Many things, like a living System of systems: Strategy, Policies, Processes, Digitalâ€”shaped by external forces such as markets and global events. Real transformation means understanding how these components interact, not treating them in isolation.</p>
        </div>
        <div class="phase-text-block" data-key="p4-hidden">
          <h1>The Hidden Relations</h1>
          <h2>HOW DEEP DOES IT GO?</h2>
          <p>Each component has its own inputs, outputs, and hidden ties to others. When those ties are mapped, patterns emergeâ€”a structure that shows why small changes ripple across the whole system.</p>
        </div>
        <div class="phase-text-block" data-key="p56-where">
          <h1>The Moment of Truth</h1>
          <h2>SHOULD YOU WALK THIS JOURNEY?</h2>
          <p>We already didâ€”and the answer is yes. But do it with eyes open. Complexity runs deeper than expected, and guidance is scarce. Thatâ€™s why we built a model that captures the whole picture and makes the path navigable.</p>
        </div>
        <div class="phase-text-block" data-key="p7-two-years">
          <h1>Locks, Locks Everywhere</h1>
          <h2>WHAT DID 2 YEARS REVEAL?</h2>
          <p>Two years of relentless work, unlocking barrier after barrier. Each layer exposed new dependencies, each cube revealed hidden ties. Piece by piece, the digital twin took shapeâ€”a living map of complexity. And just as it came together, AI leapt forward, suddenly powerful and accessible, turning years of struggle into a working reality.</p>
        </div>
        <div class="phase-text-block" data-key="p89-future">
          <h1>The Future, Ready Today</h1>
          <h2>WHAT PATH WILL YOU CHOOSE?</h2>
          <p>With the final piece in placeâ€”the very heart of the solutionâ€”the AI breathed life into the Digital Twin, reigniting hope for true transformation. The journey is not over for us or you, it continues through two distinct hubs.</p>
        </div>
        
        <!-- Two-column finale blocks that scroll up with the cube exit -->
        <div class="finale-columns" id="finaleColumns" style="display: none;">
          <div class="finale-left-column">
            <div class="finale-header">
              <img src="/assets/cosmic/twinlab-logo.png" alt="TwinLab Logo" class="finale-logo">
              <h1>TwinLab</h1>
            </div>
            <h2>KNOWLEDGE PATH</h2>
            <p>Contribute ideas, research, and insights to shape the future of transformations. Join a community of thinkers exploring the frontier of organizational complexity.</p>
            <ul>
              <li>Research Publications</li>
              <li>Case Study Database</li>
              <li>Expert Discussions</li>
              <li>Innovation Challenges</li>
            </ul>
            <button 
              class="finale-enter-btn" 
              data-nav-path="/twinlab"
              aria-label="Enter TwinLab platform"
              title="Navigate to TwinLab - Knowledge Path"
            >
              Enter
            </button>
          </div>
          <div class="finale-right-column">
            <div class="finale-header">
              <img src="/images/josoorlogo.png" alt="TwinStudio Logo" class="finale-logo">
              <h1>TwinStudio</h1>
            </div>
            <h2>BUILDER PATH</h2>
            <p>Begin your own strategy execution journey. Put the Digital Twin to work with tools, templates, and guided implementations.</p>
            <ul>
              <li>Strategy Modeling</li>
              <li>Execution Planning</li>
              <li>Risk Assessment</li>
              <li>Performance Dashboards</li>
            </ul>
            <button 
              class="finale-enter-btn" 
              data-nav-path="/twinstudio"
              aria-label="Enter TwinStudio platform"
              title="Navigate to TwinStudio - Builder Path"
            >
              Enter
            </button>
          </div>
        </div>
      </div>
    </div>

    <div class="hero-row">
      <section class="text-section"><div class="text-col">
        <h1>Transforming Strategy Execution</h1>
        <h2>COMPLEXITY AS AN ASSET</h2>
        <p>Most transformations fail because complexity overwhelms. We turned that complexity into an advantageâ€”redefining planning, risks, and dashboards inside one integrated model.</p>
      </div></section>
      <section class="text-section"><div class="text-col">
        <h1>Imagine a Parallel Universe</h1>
        <h2>WHERE TRANSFORMATIONS<br>FLOW</h2>
        <p>Let us show you a week in that universe â€” A Week in the Life of a Transformation Team &lt;video link&gt;. Farfetched? Itâ€™s here. We built the MVP: a Net.js web app with a Supabase database and a Gemini Assistant, built on a five-year scenario dataset inspired by real transformation events.</p>
      </div></section>
      <section class="text-section"><div class="text-col">
        <h1>So How Did We Do It?</h1>
        <h2>THE RIGHT QUESTIONS FIRST</h2>
        <p>Before answers, you need the right questions. This journey begins by uncovering the questions that matter mostâ€”the ones that unlock how complexity really works.</p>
      </div></section>
      <section class="text-section"><div class="text-col">
        <h1>The Anatomy of an Organization</h1>
        <h2>WHAT MAKES AN ORGANIZATION?</h2>
        <p>Many things, like a living system of systemsâ€”Strategy, Policies, Processes, Digital  shaped by external forces such as markets and global events. Real transformation means understanding how these components interact, not treating them in isolation.</p>
      </div></section>
      <section class="text-section"><div class="text-col">
        <h1>The Hidden Relations</h1>
        <h2>HOW DEEP DOES IT GO?</h2>
        <p>Each component has its own inputs, outputs, and hidden ties to others. When those ties are mapped, patterns emergeâ€”a structure that shows why small changes ripple across the whole system.</p>
      </div></section>
      <section class="text-section"><div class="text-col">
        <h1>The Moment of Truth</h1>
        <h2>SHOULD YOU WALK THIS JOURNEY?</h2>
        <p>We already didâ€”and the answer is yes. But do it with eyes open. Complexity runs deeper than expected, and guidance is scarce. Thatâ€™s why we built a model that captures the whole picture and makes the path navigable.</p>
      </div></section>
      <section class="text-section"><div class="text-col">
        <h1>Locks, Locks Everywhere</h1>
        <h2>WHAT DID 2 YEARS REVEAL?</h2>
        <p>Unlock after unlock, the journey was long and often tedious. Every piece had to be dissected, connected, and validated until a full digital twin of dependencies emerged. Just as we reached this milestone, AI leapt forwardâ€”suddenly powerful, affordable, and accessibleâ€”turning what seemed impossible into reality.</p>
      </div></section>
      <section class="text-section"><div class="text-col">
        <h1>The Future, Ready Today</h1>
        <h2>WHAT PATH WILL YOU CHOOSE?</h2>
        <p>With the AI core in place, the Digital Twin comes alive. Weâ€™ve hit a milestone, but the journey is still unfolding. Two paths now await: a Knowledge Path, where you contribute ideas and shape the future of transformations; and a Builder Path, where you begin your own strategy execution journey and put the twin to work.</p>
      </div></section>
    </div>

    <div class="sticky-canvas">
      <canvas id="stage"></canvas>
    </div>


    <div class="spacer"></div>


  </div>

  <script type="module">
    /**
     * RUBIKS CUBE ANIMATION SYSTEM
     *
     * This script implements a complex 3D Rubik's cube animation with 9 distinct phases:
     * Phase 1: Idle/Gentle Float - Large cube with gentle rotation and hover
     * Phase 2: First Dismantle - Large pieces explode into cloud formation
     * Phase 3: Settle with Perspective - Pieces hover with random rotations
     * Phase 4: Rubik Transform - Large pieces shrink, mini-cubes (729 total) grow from within
     * Phase 5: Expand to 43.3% - Mini-cubes expand outward in cloud formation
     * Phase 6: Popcorn Recolor - Mini-cubes recolor from cyan to purple one-by-one
     * Phase 7: Dance - Mini-cubes swirl and orbit in complex patterns
     * Phase 8: Morph to Sculpture - Transform into final spherical sculpture
     * Phase 9: Final Formation - Interactive phase with mouse controls
     *
     * KEY COMPONENTS:
     * - 27 Large cubes (3x3x3) with metallic patterns and randomized face arrangements
     * - 729 Mini-cubes (27x27x27) with solid blue colors that recolor to purple
     * - Procedural texture generation for realistic sticker patterns
     * - Physically-based lighting and post-processing effects
     * - Scroll-driven animation with external control support
     * - Interactive mouse controls in phases 1 and 9
     */

    import * as THREE from 'https://unpkg.com/three@0.180.0/build/three.module.js';
   // import { OrbitControls } from 'https://unpkg.com/three@0.180.0/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.180.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.180.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.180.0/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { RoomEnvironment } from 'https://unpkg.com/three@0.180.0/examples/jsm/environments/RoomEnvironment.js';

    // Background video speed control
    const bgVideo = document.querySelector('.bg-video');
    const VIDEO_PLAYBACK_RATE = 0.4;
    function applyVideoSpeed(){ try { if (bgVideo) bgVideo.playbackRate = VIDEO_PLAYBACK_RATE; } catch(_){} }
    if (bgVideo) { bgVideo.addEventListener('loadeddata', applyVideoSpeed); bgVideo.addEventListener('play', applyVideoSpeed); }
    applyVideoSpeed();

    // Navigation handler for finale buttons
    // ===== ENHANCED NAVIGATION WITH GSAP CONTEXT =====
    let navigationContext = null;
    
    function initializeNavigation() {
      // Create GSAP context for button interactions
      navigationContext = gsap.context(() => {
        // Find all navigation buttons
        const buttons = document.querySelectorAll('[data-nav-path]');
        
        buttons.forEach(button => {
          const path = button.getAttribute('data-nav-path');
          
          // Add proper event listeners using GSAP contextSafe
          const handleClick = gsap.utils.contextSafe(() => {
            console.log('Button clicked with path:', path);
            handleNavigation(path);
          });
          
          // Remove any existing onclick attributes to avoid conflicts
          button.removeAttribute('onclick');
          
          // Add proper event listener
          button.addEventListener('click', handleClick);
          
          // Add hover effects with GSAP
          button.addEventListener('mouseenter', gsap.utils.contextSafe(() => {
            gsap.to(button, { scale: 1.05, duration: 0.2, ease: "power2.out" });
          }));
          
          button.addEventListener('mouseleave', gsap.utils.contextSafe(() => {
            gsap.to(button, { scale: 1, duration: 0.2, ease: "power2.out" });
          }));
        });
      });
    }
    
    function handleNavigation(path) {
      console.log('handleNavigation called with path:', path);
      console.log('Current location:', window.location.href);
      
      try {
        // Direct navigation to external URLs
        if (path === '/twinlab') {
          console.log('Navigating to TwinLab');
          window.open('https://twinlab.ai', '_blank');
          return;
        }
        if (path === '/twinstudio') {
          console.log('Navigating to TwinStudio');
          window.open('https://twinstudio.ai', '_blank');
          return;
        }
        
        // For other paths, try hash router first, then direct navigation
        console.log('Attempting hash navigation');
        if (window.location.hash) {
          window.location.hash = '#' + path;
        } else {
          window.location.href = path;
        }
      } catch (error) {
        console.error('Navigation error:', error);
        // Enhanced fallback with more options
        if (path === '/twinlab') {
          console.log('Fallback: opening TwinLab in new tab');
          window.open('https://twinlab.ai', '_blank');
        } else if (path === '/twinstudio') {
          console.log('Fallback: opening TwinStudio in new tab');
          window.open('https://twinstudio.ai', '_blank');
        } else {
          console.log('Fallback: direct navigation to', path);
          window.location.href = path;
        }
      }
    }

    // Make navigation function globally available
    window.handleNavigation = handleNavigation;

    // ===== UTILITY FUNCTIONS =====
    /**
     * Mathematical utility functions for animation calculations
     */

    /**
     * Clamps a value between min and max bounds
     * @param {number} x - Value to clamp
     * @param {number} a - Minimum bound
     * @param {number} b - Maximum bound
     * @returns {number} Clamped value
     */
    const clamp = (x, a, b) => Math.max(a, Math.min(b, x));

    /**
     * Linear interpolation between two values
     * @param {number} a - Start value
     * @param {number} b - End value
     * @param {number} t - Interpolation factor (0-1)
     * @returns {number} Interpolated value
     */
    const lerp = (a, b, t) => a + (b - a) * t;

    /**
     * Inverse linear interpolation - finds t value for a point between a and b
     * @param {number} a - Start value
     * @param {number} b - End value
     * @param {number} v - Value to find t for
     * @returns {number} Interpolation factor (0-1)
     */
    const invLerp = (a, b, v) => clamp((v - a) / (b - a), 0, 1);

    /**
     * Smooth easing function for natural animation curves
     * Uses cubic easing for smooth acceleration/deceleration
     * @param {number} t - Input value (0-1)
     * @returns {number} Eased value (0-1)
     */
    const easeInOut = (t) => t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;

    // ===== EXTERNAL CONTROL SYSTEM =====
    /**
     * External progress control allows parent components to drive animation
     * Used by RubiksIframe component for programmatic control
     */

    /**
     * External progress override - when set, replaces scroll-based progress
     * @type {number|null} Value between 0-1, or null to use scroll
     */
    let externalProgress = null;

    /**
     * Message handler for external control from parent iframe
     * Supports two message types:
     * - RUBIKS_SET_PROGRESS: Set animation progress (0-1)
     * - RUBIKS_CLEAR_EXTERNAL: Return to scroll-based control
     */
    window.addEventListener('message', (e) => {
      const data = e && e.data;
      if (!data || typeof data !== 'object') return;
      if (data.type === 'RUBIKS_SET_PROGRESS') {
        const v = Number(data.value);
        if (!Number.isNaN(v)) externalProgress = clamp(v, 0, 1);
      } else if (data.type === 'RUBIKS_CLEAR_EXTERNAL') {
        externalProgress = null;
      }
    });

    /**
     * Calculate progress within a specific phase range
     * @param {number} global - Global progress (0-1)
     * @param {number} a - Phase start point
     * @param {number} b - Phase end point
     * @returns {number} Local phase progress (0-1)
     */
    function phaseProgress(global, a, b) { return invLerp(a, b, global); }

    // ===== VIEWPORT AND CAMERA UTILITIES =====
    /**
     * Functions for calculating camera frustum and ensuring objects fit in view
     */

    /**
     * Calculate world-space half-extents of camera viewport at distance
     * @param {THREE.Camera} cam - Camera to calculate for
     * @returns {Object} Object with halfW and halfH properties
     */
    function viewportWorldHalfExtents(cam) {
      const d = cam.position.distanceTo(new THREE.Vector3());
      const halfH = Math.tan(THREE.MathUtils.degToRad(cam.fov * 0.5)) * d;
      const halfW = halfH * cam.aspect;
      return { halfW, halfH };
    }

    /**
     * Normalized device coordinate padding - allows full viewport usage
     * Value of 1.0 means no safety margin, objects can touch viewport edges
     */
    const PAD_NDC = 1.0; // allow full viewport usage (no extra safety margin)

    /**
     * Generate all 8 corners of a cube
     * @param {THREE.Vector3} center - Cube center position
     * @param {number} half - Half-size of cube
     * @returns {THREE.Vector3[]} Array of 8 corner positions
     */
    function cubeCorners(center, half) {
      const offs = [-1, 1];
      const res = [];
      for (const dx of offs) for (const dy of offs) for (const dz of offs) {
        res.push(new THREE.Vector3(center.x + dx*half, center.y + dy*half, center.z + dz*half));
      }
      return res;
    }

    /**
     * Check if a cube fits entirely within the camera viewport
     * @param {THREE.Vector3} center - Cube center position
     * @param {number} half - Half-size of cube
     * @returns {boolean} True if cube fits in view
     */
    function cornersFitInView(center, half) {
      const corners = cubeCorners(center, half);
      for (const c of corners) {
        const p = c.clone().project(camera);
        if (Math.abs(p.x) > PAD_NDC || Math.abs(p.y) > PAD_NDC || p.z < -1 || p.z > 1) return false;
      }
      return true;
    }

    /**
     * Find maximum scale along a direction that keeps cube in viewport
     * Uses binary search to find optimal position
     * @param {THREE.Vector3} dir - Direction vector
     * @param {number} R - Maximum radius to search
     * @param {number} half - Half-size of cube
     * @returns {number} Maximum scale factor that keeps cube in view
     */
    function clampAlongDirToFit(dir, R, half) {
      // binary search max s in [0, R] such that corners fit
      let lo = 0, hi = R;
      for (let it = 0; it < 20; it++) {
        const mid = (lo + hi) * 0.5;
        const pos = dir.clone().multiplyScalar(mid);
        if (cornersFitInView(pos, half)) lo = mid; else hi = mid;
      }
      return lo;
    }

    // ===== PROCEDURAL TEXTURE GENERATION SYSTEM =====
    /**
     * Dynamic texture creation for cube faces with various patterns and colors
     *
     * PATTERN SYSTEM:
     * - 6 distinct pattern types: grid, stripes, ring, chevron, hex, wave
     * - Each pattern is procedurally generated on 512x512 canvas
     * - Navy blue color palette with gradient backgrounds
     * - Optional gloss effects for metallic appearance
     *
     * RANDOMIZATION:
     * - Large cubes: Each gets 6 shuffled patterns, one per face
     * - Mini cubes: Each gets 6 shuffled patterns, one per face
     * - Colors: 6 different blue shades for visual variety
     *
     * CACHING:
     * - Textures are cached to avoid recreation on each frame
     * - Large and mini textures cached separately
     * - Canvas-based generation for crisp, scalable results
     */
    const STICKER_CACHE = { largeTexs: null, miniTexs: null };
    const FACE_PATTERNS = ['grid','stripes','ring','chevron','hex','wave'];
    const BLUES = ['#000033','#000066','#000099','#0000CC','#000033','#000066'];

    /**
     * Create a procedural sticker texture with pattern and optional gloss
     * @param {string} pattern - Pattern type: 'grid', 'stripes', 'ring', 'chevron', 'hex', 'wave'
     * @param {string} baseHex - Base color in hex format (e.g., '#000066')
     * @param {boolean} drawPatterns - Whether to draw the pattern overlay
     * @param {boolean} drawGloss - Whether to add gloss/highlight effect
     * @returns {THREE.CanvasTexture} Generated texture for Three.js
     */
    function createStickerTexture(pattern, baseHex, drawPatterns = true, drawGloss = true){
      const size = 512; // High resolution for crisp textures
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');

      // Create gradient background for depth
      const grad = ctx.createLinearGradient(0,0,size,size);
      grad.addColorStop(0, baseHex); // Primary color
      grad.addColorStop(1, shadeHex(baseHex, -20)); // Darker shade for depth
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,size,size);

      // Inner rounded rectangle for sticker inset effect
      const inset = Math.floor(size * 0.08); // 8% inset from edges
      roundedRect(ctx, inset, inset, size-2*inset, size-2*inset, Math.floor(size*0.06));
      ctx.fillStyle = shadeHex(baseHex, -35); // Even darker for inset shadow
      ctx.globalAlpha = 0.22; // Semi-transparent inset
      ctx.fill();
      ctx.globalAlpha = 1; // Reset alpha
      // ===== PATTERN DRAWING SYSTEM =====
      /**
       * Draw specific pattern on the texture
       * Each pattern is centered and uses white strokes with drop shadows
       * for raised 3D appearance
       */
      const drawPattern = (name) => {
        ctx.save();
        ctx.translate(size/2, size/2); // Center coordinate system
        ctx.strokeStyle = 'rgba(255,255,255,1.0)'; // Pure white for maximum contrast
        ctx.fillStyle = 'rgba(255,255,255,0.3)'; // Semi-transparent white for fills
        ctx.lineWidth = Math.max(8, size*0.015); // Responsive line width

        // Drop shadow for raised 3D effect
        ctx.shadowColor = 'rgba(0,0,0,1.0)';
        ctx.shadowBlur = Math.max(12, size*0.03);
        ctx.shadowOffsetX = Math.max(5, size*0.01);
        ctx.shadowOffsetY = Math.max(5, size*0.01);
        // ===== INDIVIDUAL PATTERN IMPLEMENTATIONS =====

        if (name === 'grid') {
          // Grid pattern: Regular intersecting lines
          ctx.strokeStyle = 'rgba(255,255,255,0.8)';
          const step = Math.floor(size/10); // 10 divisions
          // Vertical lines
          for(let x=inset; x<=size-inset; x+=step){
            ctx.beginPath();
            ctx.moveTo(x,inset);
            ctx.lineTo(x,size-inset);
            ctx.stroke();
          }
          // Horizontal lines
          for(let y=inset; y<=size-inset; y+=step){
            ctx.beginPath();
            ctx.moveTo(inset,y);
            ctx.lineTo(size-inset,y);
            ctx.stroke();
          }
        } else if (name === 'stripes') {
          // Diagonal stripe pattern
          ctx.rotate(-Math.PI/6); // 30-degree angle
          for(let i=-6;i<=6;i++){
            ctx.beginPath();
            ctx.moveTo(-size, i*32);
            ctx.lineTo(size, i*32);
            ctx.stroke();
          }
        } else if (name === 'ring') {
          // Concentric ring pattern
          ctx.beginPath();
          ctx.arc(0,0,size*0.28,0,Math.PI*2); // Outer ring
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(0,0,size*0.14,0,Math.PI*2); // Inner ring
          ctx.stroke();
        } else if (name === 'chevron') {
          // Chevron/V pattern
          for(let i=0;i<4;i++){
            const off = -size*0.15 + i*size*0.1;
            ctx.beginPath();
            ctx.moveTo(-size*0.25, off);
            ctx.lineTo(0, off+size*0.08);
            ctx.lineTo(size*0.25, off);
            ctx.stroke();
          }
        } else if (name === 'hex') {
          // Hexagon pattern
          const r = size*0.22;
          ctx.beginPath();
          for(let i=0;i<6;i++){
            const a = Math.PI/3*i; // 60-degree increments
            const x = r*Math.cos(a), y=r*Math.sin(a);
            if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
          }
          ctx.closePath();
          ctx.stroke();
        } else if (name === 'wave') {
          // Sine wave pattern
          ctx.translate(-size*0.3, 0);
          for(let i=-3;i<=3;i++){
            ctx.beginPath();
            for(let x=-size*0.2; x<=size*0.2; x+=8){
              const y = Math.sin((x/50)+i)*size*0.04;
              if (x===-size*0.2) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.stroke();
          }
        }
        ctx.restore();
      };
      // Apply pattern and gloss effects
      if (drawPatterns) drawPattern(pattern);

      if (drawGloss) {
        // ===== GLOSS/HIGHLIGHT EFFECT =====
        // Creates metallic shine effect on upper portion of texture
        const gloss = ctx.createLinearGradient(0,0,0,size);
        gloss.addColorStop(0, 'rgba(255,255,255,0.22)'); // Bright highlight at top
        gloss.addColorStop(0.5, 'rgba(255,255,255,0.08)'); // Fade to middle
        gloss.addColorStop(1, 'rgba(255,255,255,0.0)'); // Transparent at bottom
        ctx.fillStyle = gloss;
        roundedRect(ctx, inset, inset, size-2*inset, Math.floor((size-2*inset)*0.55), Math.floor(size*0.06));
        ctx.fill();
      }

      // ===== TEXTURE CREATION AND OPTIMIZATION =====
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace; // Standard RGB color space
      tex.anisotropy = 8; // Anisotropic filtering for better quality at angles
      tex.needsUpdate = true; // Mark for GPU upload
      return tex;
    }
    // ===== UTILITY FUNCTIONS =====

    /**
     * Shuffle array in-place using Fisher-Yates algorithm
     * Used to randomize pattern order for visual variety
     * @param {Array} array - Array to shuffle
     * @returns {Array} Same array, shuffled in place
     */
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    /**
     * Draw rounded rectangle path on canvas
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} w - Width
     * @param {number} h - Height
     * @param {number} r - Corner radius
     */
    function roundedRect(ctx,x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    /**
     * Shade hex color by adding/subtracting brightness
     * @param {string} hex - Hex color string (with or without #)
     * @param {number} amt - Amount to add/subtract (-255 to 255)
     * @returns {string} New hex color string
     */
    function shadeHex(hex, amt){
      const c = hex.startsWith('#') ? hex.substring(1) : hex;
      const num = parseInt(c,16);
      const r = Math.min(255, Math.max(0, ((num>>16)&0xff) + amt));
      const g = Math.min(255, Math.max(0, ((num>>8)&0xff) + amt));
      const b = Math.min(255, Math.max(0, (num&0xff) + amt));
      return `#${(r<<16|g<<8|b).toString(16).padStart(6,'0')}`;
    }
    /**
     * Get cached textures for large cubes with full patterns and gloss
     * @returns {THREE.CanvasTexture[]} Array of 6 textures, one per pattern
     */
    function getLargeStickerTextures(){
      if (STICKER_CACHE.largeTexs) return STICKER_CACHE.largeTexs;
      const texs = FACE_PATTERNS.map((pat, i) => createStickerTexture(pat, BLUES[i%BLUES.length], true, true));
      STICKER_CACHE.largeTexs = texs;
      return texs;
    }

    /**
     * Get cached textures for mini cubes with solid colors (no patterns, no gloss)
     * @returns {THREE.CanvasTexture[]} Array of 6 solid color textures
     */
    function getMiniStickerTextures(){
      if (STICKER_CACHE.miniTexs) return STICKER_CACHE.miniTexs;
      const texs = FACE_PATTERNS.map((pat, i) => createStickerTexture(pat, BLUES[i%BLUES.length], false, false));
      STICKER_CACHE.miniTexs = texs;
      return texs;
    }
    function addStickers(mesh, size){
      const s = size * 0.94; // slight inset
      const offset = size/2 + 0.02;
      const mats = getLargeStickerMaterials();
      const planes = [];
      const geo = new THREE.PlaneGeometry(s, s);
      const dirs = [
        { n: new THREE.Vector3( 1, 0, 0), rot: [0, -Math.PI/2, 0] }, // +X
        { n: new THREE.Vector3(-1, 0, 0), rot: [0,  Math.PI/2, 0] }, // -X
        { n: new THREE.Vector3( 0, 1, 0), rot: [ Math.PI/2, 0, 0] }, // +Y
        { n: new THREE.Vector3( 0,-1, 0), rot: [-Math.PI/2, 0, 0] }, // -Y
        { n: new THREE.Vector3( 0, 0, 1), rot: [0, 0, 0] },           // +Z
        { n: new THREE.Vector3( 0, 0,-1), rot: [0,  Math.PI, 0] },    // -Z
      ];
      dirs.forEach((d, i) => {
        const m = new THREE.Mesh(geo, mats[i]);
        m.position.copy(d.n.clone().multiplyScalar(offset));
        m.rotation.set(d.rot[0], d.rot[1], d.rot[2]);
        m.renderOrder = 5;
        m.userData.sticker = true;
        m.name = `sticker-${i}`;
        mesh.add(m);
        planes.push(m);
      });
      return planes;
    }

    // ===== CUBE CREATION SYSTEM =====
    /**
     * Create a cube with size-appropriate materials and geometry
     *
     * SIZE-BASED MATERIAL SYSTEM:
     * - Large cubes (>0.99): MeshStandardMaterial with metallic properties and shuffled patterns
     * - Mini cubes (0.1-0.99): MeshBasicMaterial with solid blue colors for recoloring
     * - Tiny cubes (<0.1): MeshPhysicalMaterial with metallic properties
     *
     * MATERIAL PROPERTIES:
     * - Large: metalness=0.2, roughness=0.6, polygon offset for depth sorting
     * - Mini: Basic material for efficient recoloring during Phase 6
     * - Tiny: High metalness/roughness for metallic appearance
     *
     * EDGE SYSTEM:
     * - All cubes get LineSegments edges with dark navy color (#000033)
     * - Edges render on top (renderOrder=10) for crisp outlines
     * - Edges are added as children of the mesh for proper transformation
     *
     * @param {number} size - Cube size (determines material type)
     * @param {number} fillColor - Fill color for tiny cubes
     * @param {number} edgeColor - Edge color (typically dark navy)
     * @returns {THREE.Mesh} Configured cube mesh with edges
     */
    function makeCube(size, fillColor, edgeColor) {
      const geom = new THREE.BoxGeometry(size, size, size);
      let mesh;

      if (size > 0.1) {
        if (size >= 0.99) {
          // ===== LARGE CUBE CREATION =====
          // 27 large cubes forming the initial Rubik's cube structure
          const pats = shuffle(FACE_PATTERNS.slice()); // Randomize pattern order per cube
          // Load all 6 bump map textures
          const bumpTextures = [1,2,3,4,5,6].map(n => {
            const tex = new THREE.TextureLoader().load(`/assets/textures/cubeface${n}.png`);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(1, 1);
            return tex;
          });
          // Randomly assign bump map to each face
          const mats = pats.map((pat, i) => new THREE.MeshStandardMaterial({
            // map: createStickerTexture(pat, BLUES[i%BLUES.length], true, true), // Pattern overlay commented out
            color: BLUES[i%BLUES.length], // Keep color
            bumpMap: bumpTextures[Math.floor(Math.random()*6)],
            bumpScale: 1.0, // Maximum bump effect
            transparent: false, // Opaque for performance
            depthWrite: false, // Disable depth writing to prevent z-fighting
            depthTest: true, // Still test depth for proper ordering
            side: THREE.DoubleSide, // Render both sides (important for cube faces)
            metalness: 1.0, // Fully metallic
            roughness: 0.1, // Very shiny
            polygonOffset: true, // Offset depth to prevent z-fighting with edges
            polygonOffsetFactor: -4,
            polygonOffsetUnits: -4
          }));
          mesh = new THREE.Mesh(geom, mats); // Array of 6 materials, one per face
        } else {
          // ===== MINI CUBE CREATION =====
          // 729 mini cubes that emerge from within large cubes
         // const miniMaterial = new THREE.MeshStandardMaterial({
          // --- ORIGINAL MINI CUBE MATERIAL CREATION (commented out) ---
          // const miniMaterial = new THREE.MeshStandardMaterial({
          //   color: new THREE.Color(0x0066CC), // Blue color for mini-cubes
          //   transparent: false, // Opaque
          //   opacity: 1.0, // Fully opaque
          //   depthWrite: true, // Enable depth writing to prevent see-through
          //   depthTest: true, // Test depth
          //   side: THREE.DoubleSide, // Render both sides
          //   metalness: 0.25, // Balanced metallic feel
          //   roughness: 0.5 // Balanced surface roughness
          // });
          // mesh = new THREE.Mesh(geom, miniMaterial); // Single metallic material for all faces

          // --- MINI CUBE MATERIAL WITH NO GLOW/EMISSIVE ---
          const miniMaterial = new THREE.MeshStandardMaterial({
            color: new THREE.Color(0x0066CC),
            transparent: false,
            opacity: 1.0,
            depthWrite: true,
            depthTest: true,
            side: THREE.DoubleSide,
            metalness: 0.25,
            roughness: 0.5,
            emissive: new THREE.Color(0x000000), // No glow
            emissiveIntensity: 0.0 // No glow
          });
          mesh = new THREE.Mesh(geom, miniMaterial); // Single metallic material for all faces
        }
      } else {
        // ===== TINY CUBE CREATION =====
        // Smallest cubes in final sculpture formation
        const mat = new THREE.MeshPhysicalMaterial({
          color: fillColor,
          metalness: 1.0, // Highly metallic
          roughness: 0.25, // Smooth surface
          clearcoat: 1.0, // Clear coat layer for extra shine
          clearcoatRoughness: 0.15, // Smooth clear coat
//          envMapIntensity: 1.2 // Environment reflection intensity
        });
        mesh = new THREE.Mesh(geom, mat); // Single material for all faces
      }
      // ===== MESH CONFIGURATION =====
      mesh.castShadow = true; // Cast shadows for depth
      mesh.receiveShadow = true; // Receive shadows from other objects

      // ===== EDGE CREATION =====
      // Add edges for all cubes, but make mini-cube edges very thin
      const edges = new THREE.LineSegments(
        new THREE.EdgesGeometry(geom), // Extract edges from box geometry
        new THREE.LineBasicMaterial({
          color: edgeColor, // Use provided edge color
          linewidth: size >= 0.99 ? 1 : 0.5 // Thin lines for mini-cubes
        })
      );
      edges.renderOrder = 10; // Render edges on top of faces
      mesh.add(edges); // Add as child so edges follow mesh transformations

      return mesh;
    }

    /**
     * Set fill color for all meshes in a 3D object hierarchy
     * Used for global color changes during different animation phases
     * @param {THREE.Object3D} obj3D - Root object to traverse
     * @param {number} color - Color value (hex number)
     */
    function setCubeFillColor(obj3D, color) {
      obj3D.traverse(o => {
        if (o.isMesh && o.material) {
          if (Array.isArray(o.material)) {
            // Handle multi-material meshes (cubes with different face materials)
            o.material.forEach(m => { if (m && m.color) m.color.set(color); });
          } else {
            // Handle single-material meshes
            if (o.material.color) o.material.color.set(color);
          }
        }
      });
    }

    // ===== SCENE SETUP AND RENDERING =====

    // Canvas and renderer configuration
    const canvas = document.getElementById('stage');
    const containerEl = document.querySelector('.sticky-canvas');
    
    // Guard against multiple initialization
  if (window.__rubiksInit) {}
    window.__rubiksInit = true;
    
    // Create WebGL context explicitly with fallbacks
    const contextOptions = { 
      alpha: true, 
      antialias: false, 
      depth: true, 
      stencil: false, 
      powerPreference: 'high-performance', 
      failIfMajorPerformanceCaveat: false 
    };
    
    const gl = canvas.getContext('webgl2', contextOptions) || 
               canvas.getContext('webgl', contextOptions) || 
               canvas.getContext('experimental-webgl', contextOptions);
    
    if (!gl) {
      console.error('WebGL unavailable in this iframe');
      canvas.style.background = 'linear-gradient(45deg, #1a1a2e, #16213e)';
      const fallbackMsg = document.createElement('div');
      fallbackMsg.innerHTML = `
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                    color: white; text-align: center; font-family: Arial;">
          <h3>3D Graphics Unavailable</h3>
          <p>WebGL is not supported in this environment.</p>
        </div>`;
  canvas.parentElement.appendChild(fallbackMsg);
  // No top-level return; fallback message shown, rest of script will not execute WebGL logic
    }
    
    console.log('WebGL context created:', gl.getParameter(gl.VERSION));
    
    const renderer = new THREE.WebGLRenderer({ 
      canvas, 
      context: gl,
      alpha: true
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5)); // Conservative pixel ratio
    
    // Handle context loss
    canvas.addEventListener('webglcontextlost', e => { 
      e.preventDefault(); 
      console.warn('WebGL context lost'); 
    });
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => { 
      if (renderer.forceContextLoss) renderer.forceContextLoss();
      if (renderer.dispose) renderer.dispose();
    });
    renderer.outputColorSpace = THREE.SRGBColorSpace; // Standard color space
    renderer.toneMapping = THREE.ACESFilmicToneMapping; // Film-like color grading
    renderer.toneMappingExposure = 1.0; // Normal exposure
    renderer.setClearColor(0x000000, 0); // Transparent clear color
    renderer.setClearAlpha && renderer.setClearAlpha(0); // Full transparency
    renderer.autoClear = true;
    renderer.domElement.style.background = 'transparent';

    const scene = new THREE.Scene();

    // ===== PHYSICALLY-BASED LIGHTING SYSTEM =====
    // Environment and lighting setup for realistic metallic materials
    renderer.physicallyCorrectLights = true; // Enable PBR lighting
    const pmrem = new THREE.PMREMGenerator(renderer);
    const envTex = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
    scene.environment = envTex; // Environment map for reflections

    // ===== CAMERA CONFIGURATION =====
    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 500);
    const CAMERA_TARGET_Y = -0.6; // Offset look target for better composition
    camera.position.set(6, 4, 12); // Initial camera position
    camera.lookAt(0, CAMERA_TARGET_Y, 0); // Look at cube center with vertical offset

    // ===== LIGHTING SETUP =====
    // Hemisphere light for ambient illumination
    const hemi = new THREE.HemisphereLight(0x8aa4ff, 0x0e0f15, 0.7);
    scene.add(hemi);

  // Directional light for key lighting and shadows
  const dir = new THREE.DirectionalLight(0xffffff, 2.5); // Increased intensity for bump mapping
  dir.position.set(6, 10, 8); // Position above and to the side
  dir.castShadow = true; // Enable shadow casting
  scene.add(dir);

  // Add a second directional light from the opposite angle for better face illumination
  const dir2 = new THREE.DirectionalLight(0xffffff, 2.5);
  dir2.position.set(6, 4, 12); // Match camera position
  dir2.target = new THREE.Object3D();
  dir2.target.position.set(0, -0.6, 0); // Match camera lookAt
  scene.add(dir2.target);
  dir2.castShadow = false;
  scene.add(dir2);

    // PostFX
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    renderPass.clear = true;
    renderPass.clearAlpha = 0.0;
    composer.addPass(renderPass);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(1, 1), 0.7, 0.7, 0.2);
    bloomPass.enabled = false;
    composer.addPass(bloomPass);
    let bloomEnabled = false;

    // Root group
    const root = new THREE.Group();
    scene.add(root);

    // ===== LARGE CUBE SYSTEM (27 PIECES) =====
    /**
     * Create the initial 3x3x3 Rubik's cube structure
     * These 27 large cubes form the foundation of the animation
     */

    const LARGE_SIZE = 1.0; // Base size for large cubes
    const GAP = 0.08; // Gap between cubes for visual separation
    const STEP = LARGE_SIZE + GAP; // Total spacing including gap
    const largePieces = []; // Array to store all large cube meshes

    const largeGroup = new THREE.Group(); // Group for collective transformations
    root.add(largeGroup);

    // Generate 3x3x3 grid of large cubes
    for (let x = -1; x <= 1; x++) {
      for (let y = -1; y <= 1; y++) {
        for (let z = -1; z <= 1; z++) {
          const cube = makeCube(LARGE_SIZE, 0x00f0ff, 0xffffff);
          cube.position.set(x * STEP, y * STEP, z * STEP); // Position in grid
          largeGroup.add(cube);
          largePieces.push(cube);
        }
      }
    }

    // Store initial positions for Phase 1 reversible animation
    const initialLargePositions = largePieces.map(p => p.position.clone());

    // Scale 1.5x initially (Phase 1 requirement)
    largeGroup.scale.setScalar(1.5);
    const PHASE1_INITIAL_SCALE = largeGroup.scale.x;
    const PHASE1_SPAN = (2 * STEP + LARGE_SIZE) * PHASE1_INITIAL_SCALE; // full Rubik cube width (centers span + one cube size)

    // ===== Outer Frame (12 thick beams) and Core Sphere/Light =====
    const frameGroup = new THREE.Group();
    root.add(frameGroup);
    const frameSize = PHASE1_SPAN; // exactly Phase 1 Rubik cube span
    const frameThickness = frameSize * (0.06 / 2.2); // keep beam thickness ratio from reference
    const half = frameSize * 0.5;
  // const beamMat = new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 1.0, roughness: 0.2, envMapIntensity: 1.0 }); // original: white
  const beamMat = new THREE.MeshPhysicalMaterial({ color: 0xFFD700, metalness: 1.0, roughness: 0.2, envMapIntensity: 1.0 }); // gold
    function beam(w,h,d,x,y,z){ const g=new THREE.BoxGeometry(w,h,d); const m=new THREE.Mesh(g, beamMat); m.position.set(x,y,z); frameGroup.add(m); }
    // 4 vertical
    beam(frameThickness, frameSize, frameThickness, -half, 0, -half);
    beam(frameThickness, frameSize, frameThickness, -half, 0,  half);
    beam(frameThickness, frameSize, frameThickness,  half, 0, -half);
    beam(frameThickness, frameSize, frameThickness,  half, 0,  half);
    // top
    beam(frameSize, frameThickness, frameThickness, 0,  half, -half);
    beam(frameSize, frameThickness, frameThickness, 0,  half,  half);
    beam(frameThickness, frameThickness, frameSize, -half, half, 0);
    beam(frameThickness, frameThickness, frameSize,  half, half, 0);
    // bottom
    beam(frameSize, frameThickness, frameThickness, 0, -half, -half);
    beam(frameSize, frameThickness, frameThickness, 0, -half,  half);
    beam(frameThickness, frameThickness, frameSize, -half,-half, 0);
    beam(frameThickness, frameThickness, frameSize,  half,-half, 0);
    frameGroup.visible = false;

    const coreSphere = new THREE.Mesh(
      new THREE.SphereGeometry(PHASE1_SPAN * 0.14, 48, 48),
      new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 1.0, roughness: 0.15, envMapIntensity: 1.0, emissive: 0xC084FC, emissiveIntensity: 0.35 })
    );
    coreSphere.castShadow = false; coreSphere.receiveShadow = false; coreSphere.visible = false; root.add(coreSphere);
    const coreLight = new THREE.PointLight(0x9f7bff, 2.0, PHASE1_SPAN * 3.0); root.add(coreLight); coreLight.visible = false;

    // ===== MINI CUBE SYSTEM (729 PIECES) =====
    /**
     * Create the inner 729 mini-cubes that emerge from within the large cubes
     * Each large cube contains a 3x3x3 grid of mini-cubes (27 total per large cube)
     * Mini-cubes are initially hidden and grow during Phase 4 transformation
     */

    const MINI_SIZE = 0.28; // Size of mini-cubes (smaller than large)
    const MINI_GAP = 0.06; // Gap between mini-cubes
    const MINI_STEP = MINI_SIZE + MINI_GAP; // Total spacing for mini-cubes
    const miniGroup = new THREE.Group(); // Group for collective mini-cube operations
    root.add(miniGroup);
    miniGroup.visible = false; // Hidden until Phase 4 reveals them
    const miniCubes = []; // Array to store all 729 mini-cube meshes

    // Generate mini-cubes within each large cube
    for (let ownerIndex = 0; ownerIndex < largePieces.length; ownerIndex++) {
      const lp = largePieces[ownerIndex];
      const base = lp.position.clone(); // Position relative to owning large cube

      // Create 3x3x3 grid within each large cube
      for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
          for (let k = -1; k <= 1; k++) {
            const m = makeCube(MINI_SIZE, 0x1f2937, 0xffffff);
            m.position.set(base.x + i * MINI_STEP, base.y + j * MINI_STEP, base.z + k * MINI_STEP);

            // Store relationship data for animation logic
            m.userData.ownerIndex = ownerIndex; // Which large cube owns this mini
            m.userData.local = new THREE.Vector3(i, j, k); // Local position within 3x3x3 grid
            m.userData.isCenter = (i === 0 && j === 0 && k === 0); // Center mini-cube flag
            m.userData.base = new THREE.Vector3(i, j, k); // Base position for animations
            m.userData.initialScale = 0.0001; // Start tiny for growth animation
            m.scale.setScalar(m.userData.initialScale);

            miniGroup.add(m);
            miniCubes.push(m);
          }
        }
      }
    }

    // ===== UI/Interaction =====
    const progressEl = document.getElementById('progress');
    const phaseLabelEl = document.getElementById('phaseLabel');
    const mouseLabelEl = document.getElementById('mouseLabel');
    const metricsEl = document.getElementById('metrics');
    const coordsEl = document.getElementById('coordsPanel');
    const bgTintEl = document.querySelector('.bg-tint');

    const SAMPLE_LARGE = [0, 1, 13, 26];
    const SAMPLE_MINI = [13, 40, 364, 715];
    function fmt(v) { return `${v.x.toFixed(2)}, ${v.y.toFixed(2)}, ${v.z.toFixed(2)}`; }
    let lastCoordsUpdate = 0;
    function updateCoords(phaseId) {
      if (!coordsEl) return;
      if (perf.now - lastCoordsUpdate < 100) return; // ~10 fps update cap
      lastCoordsUpdate = perf.now;
      let out = `Phase: ${phaseLabelEl.textContent}\n\n`;
      out += `Large cubes (sample indices ${SAMPLE_LARGE.join(', ')}):\n`;
      SAMPLE_LARGE.forEach(i => {
        const lp = largePieces[i];
        if (lp) {
          const wp = lp.getWorldPosition(new THREE.Vector3());
          out += `L[${i}]: (${fmt(wp)})\n`;
        }
      });
      if (miniGroup.visible) {
        out += `\nMini cubes (sample indices ${SAMPLE_MINI.join(', ')}):\n`;
        SAMPLE_MINI.forEach(i => {
          const m = miniCubes[i];
          if (m) {
            const wp = m.getWorldPosition(new THREE.Vector3());
            out += `m[${i}]: (${fmt(wp)})\n`;
          }
        });
      }
      coordsEl.textContent = out;
    }

    // Phase 1 anchor snapshot (strict handover)
    let phase1AnchorSet = false;
    const phase1Anchor = { largePositions: [], largeScale: 1.5, rootRotation: new THREE.Vector2() };

    // Phase 2 preparation (from Phase 1 end-state)
    let phase2Prepared = false;
    let phase2FromPositions = [];
    let phase2EndPositions = []; // exact end-state of Phase 2 for strict handover

    // Phase 3 preparation (from Phase 2 end-state)
    let phase3Prepared = false;
    let phase3FromPositions = [];
    let phase3FromScale = 1.5;
    let phase3BaseRotations = [];
    let phase3Axes = [];
    let phase3Speeds = []; // radians per second
    let phase3StartTime = 0; // zero hover/rotation on entry so Phase 2 is exact start
    const PHASE3_HOVER_AMP = 0.06;
    const PHASE3_HOVER_FREQ = 0.6;

    // Phase 4 preparation (from Phase 3 end-state)
    let phase4Prepared = false;
    let phase4FromLargePositions = [];
    let phase4FromLargeQuats = [];
    let phase4EndPositions = [];

    // Phase 5 preparation (from Phase 4 end-state)
    let phase5Prepared = false;
    let phase5StartPositions = [];
    let phase5EndPositions = [];
    let phase5Dirs = [];

    // Phase 6 preparation (from Phase 5 end-state)
    let phase6Prepared = false;
    let phase6AnchorPositions = [];
    let phase6EndPositions = [];
    let phase6ColorOrder = [];
    let phase6Activation = [];

    // Phase 7 preparation (from Phase 6 end-state)
    let phase7Prepared = false;
    let phase7StartPositions = [];
    let phase7Dirs = [];
    let phase7Swirl = [];

    // Phase 8 preparation (from Phase 7 end-state)
    let phase8Prepared = false;
    let phase8StartPositions = [];

    // Phases 5  8 preparation (anchored from end of Phase 4)
    let phase58Prepared = false;
    let phase58StartPositions = [];
    let phase58Dirs = [];
    let phase58Swirl = [];
    let phase58ClusterIds = [];

    // Fixed camera: derive once from initial position
    const INITIAL_DIR = camera.position.clone().normalize();
    const FIXED_DISTANCE = camera.position.length() * 1.8;
    camera.position.copy(INITIAL_DIR.clone().multiplyScalar(FIXED_DISTANCE));

    const resetBtn = document.getElementById('reset');
    if (resetBtn) {
      resetBtn.addEventListener('click', () => {
        camera.position.copy(INITIAL_DIR.clone().multiplyScalar(FIXED_DISTANCE));
        camera.lookAt(0, CAMERA_TARGET_Y, 0);
        targetRot.set(0, 0);
      });
    }
    const toggleBloomBtn = document.getElementById('toggleBloom');
    if (toggleBloomBtn) {
      toggleBloomBtn.addEventListener('click', () => {
        bloomEnabled = !bloomEnabled; bloomPass.enabled = bloomEnabled;
      });
    }

    // Mouse rotation mapping for Phase 1 and 9
    const pointer = new THREE.Vector2();
    const targetRot = new THREE.Vector2();
    window.addEventListener('mousemove', (e) => {
      const r = canvas.getBoundingClientRect();
      pointer.x = ((e.clientX - r.left) / r.width) * 2 - 1;
      pointer.y = ((e.clientY - r.top) / r.height) * 2 - 1;
      targetRot.set(pointer.y * 0.4, pointer.x * 0.6);
    });

    // click-and-drag full rotation controls (phases 1 and 9)
    let isDragging = false;
    let dragLast = { x: 0, y: 0 };
    const SPIN_SENS = 0.01; // radians per pixel
    let inInteractivePhase = false;
    if (canvas) canvas.style.touchAction = 'none';

    function onPointerDown(e){
      isDragging = true;
      dragLast.x = e.clientX; dragLast.y = e.clientY;
      try { canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId); } catch(_){}
      e.preventDefault();
    }
    function onPointerMove(e){
      if (!isDragging) return;
      const dx = e.clientX - dragLast.x;
      const dy = e.clientY - dragLast.y;
      dragLast.x = e.clientX; dragLast.y = e.clientY;
      if (inInteractivePhase) {
        root.rotation.y += dx * SPIN_SENS;
        root.rotation.x += dy * SPIN_SENS;
      }
      e.preventDefault();
    }
    function onPointerUp(e){
      isDragging = false;
      try { canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId); } catch(_){}
      e.preventDefault();
    }
    canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
    window.addEventListener('pointermove', onPointerMove, { passive: false });
    window.addEventListener('pointerup', onPointerUp, { passive: false });
    window.addEventListener('pointerleave', onPointerUp, { passive: false });

    // Scroll progress [0..1]
    function globalProgress() {
      if (externalProgress !== null) return externalProgress;
      const maxScroll = document.body.scrollHeight - window.innerHeight;
      return maxScroll > 0 ? clamp(window.scrollY / maxScroll, 0, 1) : 0;
    }

    // Intro scaling over first three text sections (scroll-driven)
    const INTRO_SECTIONS = 3;
    const INTRO_START_SCALE = 3.0; // begins at 2x Phase 1 size
    function firstThreeScrollT() {
      if (externalProgress !== null) return 1; // parent-controlled, skip intro gating
      const a = window.innerHeight * INTRO_SECTIONS;
      return clamp(window.scrollY / Math.max(1, a), 0, 1);
    }

    // ===== ANIMATION PHASE SYSTEM =====
    /**
     * 9 distinct animation phases triggered by scroll progress
     * Each phase has specific timing, behavior, and visual characteristics
     *
     * PHASE TIMING (as percentage of total scroll):
     * 1: 0.00-2.01% - Initial idle state with gentle floating
     * 2: 2.01-12.06% - Large cubes explode into cloud formation
     * 3: 12.06-14.48% - Pieces settle with random rotations
     * 4: 14.48-31.38% - Large cubes shrink, mini-cubes emerge
     * 5: 31.38-43.0% - Mini-cubes expand outward in cloud
     * 6: 43.0-52.0% - Mini-cubes recolor cyan to purple one-by-one
     * 7: 52.0-62.0% - Mini-cubes swirl and orbit in complex patterns
     * 8: 62.0-70.0% - Transform into final spherical sculpture
     * 9: 70.0-100% - Interactive final formation with mouse controls
     */
    const PHASES = [
      { id: 1, start: 0.00, end: 0.0201, label: 'Phase 1 â€” Idle / Gentle Float' },
      { id: 2, start: 0.0201, end: 0.1206, label: 'Phase 2 â€” First Dismantle / Dramatic Cloud' },
      { id: 3, start: 0.1206, end: 0.1448, label: 'Phase 3 â€” Settle with Perspective' },
      { id: 4, start: 0.1448, end: 0.3138, label: 'Phase 4 â€” Rubik Transform' },
      { id: 5, start: 0.3138, end: 0.43, label: 'Phase 5 â€” Expand to 43.3%' },
      { id: 6, start: 0.43, end: 0.52, label: 'Phase 6 â€” Popcorn Recolor' },
      { id: 7, start: 0.52, end: 0.62, label: 'Phase 7 â€” Dance' },
      { id: 8, start: 0.62, end: 0.70, label: 'Phase 8 â€” Final Morph' },
      { id: 9, start: 0.70, end: 1.0, label: 'Phase 9 â€” Final Formation' }
    ];

    // Fixed dismantle radius for Phase 2 (no viewport-based formula)
    const PHASE2_RADIUS = 8.0;

    /*
      NOTE: Alternative dynamic formula (to be tested only after final phase is done)

      function dynamicPhase2Radius() {
        const { halfW, halfH } = viewportWorldHalfExtents(camera);
        const halfMin = Math.min(halfW, halfH);
        const groupScale = largeGroup.scale.x;
        const pieceHalf = Math.sqrt(3) * (LARGE_SIZE * groupScale) / 2;
        return Math.max(halfMin * PAD_NDC - pieceHalf, STEP * 2);
      }

      function projectCornersWithinPad(center, halfDiag) {
        const corners = [
          new THREE.Vector3( 1, 1, 1), new THREE.Vector3( 1, 1,-1),
          new THREE.Vector3( 1,-1, 1), new THREE.Vector3( 1,-1,-1),
          new THREE.Vector3(-1, 1, 1), new THREE.Vector3(-1, 1,-1),
          new THREE.Vector3(-1,-1, 1), new THREE.Vector3(-1,-1,-1)
        ];
        for (const c of corners) {
          const p = center.clone().add(c.multiplyScalar(halfDiag)).project(camera);
          if (Math.abs(p.x) > PAD_NDC || Math.abs(p.y) > PAD_NDC) return false;
        }
        return true;
      }
      // Usage idea:
      // const R = dynamicPhase2Radius();
      // const dir = largeDirs[i];
      // binary search s in [0,R] where projectCornersWithinPad(dir*s, pieceHalf) == true
    */

    /**
     * Determine which animation phase corresponds to current progress
     * @param {number} g - Global progress (0-1)
     * @returns {Object} Phase object with id, start, end, and label
     */
    function getPhase(g) {
      for (const p of PHASES) if (g >= p.start && g <= p.end) return p; return PHASES[PHASES.length-1];
    }

    // ===== Layout helpers =====
    function cloudRadiusForLarge() {
      const { halfW, halfH } = viewportWorldHalfExtents(camera);
      const halfMin = Math.min(halfW, halfH);
      const pieceHalf = Math.sqrt(3) * (LARGE_SIZE * 0.5) * 1.5; // include initial scale 1.5
      return Math.max(halfMin * 0.90 - pieceHalf, STEP * 2);
    }

    function cloudRadiusForMini() {
      const { halfW, halfH } = viewportWorldHalfExtents(camera);
      const halfMin = Math.min(halfW, halfH);
      const pieceHalf = Math.sqrt(3) * (MINI_SIZE * 0.5);
      return Math.max(halfMin * 0.95 - pieceHalf, MINI_STEP * 8);
    }

    // Precompute normalized directions for each large piece from center
    const largeDirs = largePieces.map(p => {
      const v = p.position.clone().normalize();
      if (v.lengthSq() === 0) v.set(Math.random()*2-1, Math.random()*2-1, Math.random()*2-1).normalize();
      return v;
    });

    // Utilities for deterministic pseudo-random
    function hash11(x){
      let t = (x>>>0) * 2654435761 >>> 0; t ^= t << 13; t ^= t >>> 17; t ^= t << 5; return (t>>>0) / 4294967295;
    }

    // Final sculpture targets (layered spherical distribution with oriented/elongated minis)
    const sculpturePos = new Array(miniCubes.length);
    const sculptureQuat = new Array(miniCubes.length);
    const sculptureScale = new Array(miniCubes.length);
    (function buildSculpture(){
      const layers=9, latSteps=9, lonSteps=9;
      const baseR = frameSize * (0.92 / 2.2); // match reference ratio, scaled to Phase 1 frame
      let k=0;
      for(let l=0; l<layers; l++){
        const r = 0.55 + (l/(layers-1))*0.40;
        for(let a=0; a<latSteps; a++){
          const phi = Math.PI * (a+0.5)/latSteps;
          for(let b=0; b<lonSteps; b++){
            const theta = 2*Math.PI*(b/lonSteps);
            const nx = Math.sin(phi)*Math.cos(theta);
            const ny = Math.cos(phi);
            const nz = Math.sin(phi)*Math.sin(theta);
            const rad = baseR*r;
            const px=nx*rad, py=ny*rad, pz=nz*rad;
            const q=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), new THREE.Vector3(nx,ny,nz));
            const elong = 1.0 + 0.85*((a%3===0?0.9:0.4)+0.15*Math.sin((a+b+l)*0.7));
            const s=new THREE.Vector3(1,1,elong);
            sculpturePos[k]=new THREE.Vector3(px,py,pz);
            sculptureQuat[k]=q;
            sculptureScale[k]=s;
            k++;
          }
        }
      }
    })();

    // ===== Text-Phase Sync (pin text while animation runs given phases) =====
    function setupPhaseTextSync(){
      const sections = Array.from(document.querySelectorAll('.hero-row .text-section'));
      if (sections.length < 8) return; // expect 8 sections
      // Use a fixed scroll budget (the spacer) to avoid feedback loops that desync phases
      const spacer = document.querySelector('.spacer');
      const baseBudget = spacer ? parseFloat(getComputedStyle(spacer).height) || 18000 : 18000;
      // Mapping of section index (0-based) to one or more animation phases to pin through
      const mapping = new Map([
        [3, [2,3]],   // The Anatomy of an Organization: P2 + P3
        [4, [4]],     // The Hidden Relations: P4
        [5, [5,6]],   // The Moment of Truth: P5 + P6
        [6, [7]],     // Locks, Locks Everywhere: P7
        [7, [8,9]],   // The Future, Ready Today: P8 + P9
      ]);
      let totalPads = 0;
      sections.forEach((sec, idx) => {
        let pad = sec.querySelector('.phase-pad');
        if (!pad) { pad = document.createElement('div'); pad.className = 'phase-pad'; sec.appendChild(pad); }
        let targetPx = 0;
        const phaseIds = mapping.get(idx);
        if (phaseIds){
          const ids = Array.isArray(phaseIds) ? phaseIds : [phaseIds];
          for (const id of ids) {
            const p = PHASES.find(pp => pp.id === id);
            if (p) targetPx += Math.max(0, Math.floor((p.end - p.start) * baseBudget));
          }
        }
        const needed = Math.max(0, targetPx);
        pad.style.height = needed + 'px';
        totalPads += needed;
      });
      // Offset pads by shrinking the spacer so total scroll stays aligned with the animationâ€™s timeline
      if (spacer) {
        const minTail = 600; // keep extra tail so last sticky stays pinned through P9
        const newHeight = Math.max(minTail, baseBudget - totalPads + minTail);
        spacer.style.height = newHeight + 'px';
      }
    }

    // ===== UNIFIED GSAP TIMELINE SYSTEM =====
    const overlayRoot = document.getElementById('phaseOverlay');
    const overlayBlocks = overlayRoot ? Array.from(overlayRoot.querySelectorAll('.phase-text-block')) : [];
    const overlayOrder = ['intro-1','intro-2','intro-3','p23-your-org','p4-hidden','p56-where','p7-two-years','p89-future'];
    const orderIndex = new Map(overlayOrder.map((k,i)=>[k,i]));
    let activeKey = '';
    let lastActiveEl = null;
    let overlayViewport = null;
    
    // ===== MASTER TIMELINE FOR SYNCHRONIZED ANIMATIONS =====
    let masterTimeline = null;
    let cubeAnimationTween = null;
    let textAnimationTween = null;
    let isTimelineReversed = false;
    let currentPhaseIndex = 0;
    
    function initializeMasterTimeline() {
      if (masterTimeline) {
        masterTimeline.kill();
      }
      
      // Create master timeline with smooth child timing enabled
      masterTimeline = gsap.timeline({
        smoothChildTiming: true,
        paused: true,
        onUpdate: function() {
          // Sync Three.js rendering with GSAP timeline progress
          const progress = this.progress();
          updateThreeJSFromTimeline(progress);
        }
      });
      
      // Add phase animations with proper sequencing
      setupPhaseAnimations();
    }
    
    function setupPhaseAnimations() {
      // Phase 1-2: Intro with 5% pause
      masterTimeline.set({}, {}, 0)
        .to({}, { duration: 0.05 }, "phase1-pause")
        
      // Phase 7: Brief pause (5%)
        .to({}, { duration: 0.05 }, "phase7-pause")
        
      // Phase 8-9: Text exit and cube movement synchronized
        .add("finale-start")
        .to({}, { 
          duration: 1.8, 
          ease: "power2.out",
          onUpdate: function() {
            updateFinaleSync(this.progress());
          }
        }, "finale-start");
    }
    
    function updateThreeJSFromTimeline(progress) {
      // Map timeline progress to global animation phase
      const mappedProgress = progress;
      
      // Update cube animations based on timeline progress
      if (cubeAnimationTween) {
        cubeAnimationTween.progress(mappedProgress);
      }
      
      // Sync text animations
      updateTextSync(mappedProgress);
    }
    
    function hideAllExcept(a,b){ overlayBlocks.forEach(el => { el.style.visibility = (el===a || el===b) ? 'visible' : 'hidden'; }); }

    function setupOverlayViewport(){
      if (!overlayRoot) return;
      const inner = overlayRoot.querySelector('.overlay-inner');
      if (!inner) return;
      if (!overlayViewport) {
        overlayViewport = inner.querySelector('.phase-viewport');
        if (!overlayViewport) {
          overlayViewport = document.createElement('div');
          overlayViewport.className = 'phase-viewport';
          const blocks = Array.from(inner.querySelectorAll('.phase-text-block'));
          blocks.forEach(el => overlayViewport.appendChild(el));
          inner.appendChild(overlayViewport);
        }
      }
      measureViewport();
    }

    function measureViewport(){
      if (!overlayViewport) return;
      overlayViewport.style.height = '600px';
    }

    window.addEventListener('resize', () => { measureViewport(); });

    function setActive(key){
      if (!overlayRoot || key === activeKey) return;
      setupOverlayViewport();
      const nextEl = overlayBlocks.find(el => el.getAttribute('data-key') === key) || null;
      const prevEl = overlayBlocks.find(el => el.classList.contains('active')) || null;
      activeKey = key;
      overlayRoot.setAttribute('data-active', key);

      // Use GSAP timeline for proper text transitions
      if (textAnimationTween) {
        textAnimationTween.kill();
      }
      
      // Create text transition timeline with proper sequencing
      textAnimationTween = gsap.timeline({
        duration: 1.8,
        ease: "power2.out",
        onComplete: function() {
          measureViewport();
        }
      });

      // Clear previous active states
      overlayBlocks.forEach(el => el.classList.remove('active'));
      
      if (nextEl) {
        nextEl.classList.add('active');
        
        // Set up transition direction
        const H = (overlayViewport && overlayViewport.clientHeight) ? overlayViewport.clientHeight : 600;
        const prevKey = prevEl ? prevEl.getAttribute('data-key') : null;
        const nextKey = nextEl ? nextEl.getAttribute('data-key') : null;
        const idxPrev = prevKey != null ? (orderIndex.get(prevKey) ?? 0) : -1;
        const idxNext = nextKey != null ? (orderIndex.get(nextKey) ?? 0) : 0;
        const forward = (idxPrev === -1) ? true : (idxNext > idxPrev);

        // Set visibility for transitioning elements
        overlayBlocks.forEach(el => { 
          el.style.visibility = (el === prevEl || el === nextEl) ? 'visible' : 'hidden'; 
        });

        // Animate out previous element if exists
        if (prevEl) {
          textAnimationTween.fromTo(prevEl, 
            { y: 0 },
            { 
              y: forward ? -H : H, 
              duration: 0.9,
              ease: "power2.out",
              onComplete: () => { 
                prevEl.style.visibility = 'hidden'; 
                prevEl.classList.remove('active');
              }
            }, 
            0
          );
        }

        // Animate in next element
        textAnimationTween.fromTo(nextEl, 
          { y: forward ? H : -H, visibility: 'visible' },
          { y: 0, duration: 0.9, ease: "power2.out" }, 
          prevEl ? 0.9 : 0
        );
      }

      lastActiveEl = nextEl;
    }
    function updateOverlayText(gPhase, introT){
      const p = getPhase(gPhase).id;
      if (p === 1 && externalProgress === null) {
        if (introT < 0.33) setActive('intro-1');
        else if (introT < 0.66) setActive('intro-2');
        else setActive('intro-3');
        return;
      }
      if (p===2 || p===3) return setActive('p23-your-org');
      if (p===4) return setActive('p4-hidden');
      if (p===5 || p===6) return setActive('p56-where');
      if (p===7) {
        // Phase 7: Add noticeable 5% pause when small purple cubes form circles
        const phase7 = PHASES[6];
        const phase7Start = phase7.start;
        const phase7End = phase7.end;
        const phase7Progress = clamp((gPhase - phase7Start) / (phase7End - phase7Start), 0, 1);
        
        if (phase7Progress < 0.95) {
          // Normal phase 7 text for 95% of the phase
          setActive('p7-two-years');
        } else {
          // 5% pause at the end - keep text visible and prevent transition to phase 8
          setActive('p7-two-years');
          // Add visual indication of pause (optional)
          const overlay = document.querySelector('.phase-text-block[data-key="p7-two-years"]');
          if (overlay) {
            overlay.style.opacity = '0.8'; // Slightly fade to indicate pause
          }
        }
        return;
      }
      if (p===8) {
        setActive('p89-future');
      }
      if (p===9) {
        // Calculate scroll progress within phase 9
        const phase9 = PHASES[8];
        const phase9Start = phase9.start;
        const phase9End = phase9.end;
        const scrollProgress = clamp((gPhase - phase9Start) / (phase9End - phase9Start), 0, 1);
        
        // Phase 9: Synchronize text and cube exit at exactly the same time (0%)
        const overlay = document.querySelector('.phase-text-block[data-key="p89-future"]');
        
        if (scrollProgress === 0) {
          // At the very start of phase 9 - keep text active briefly
          setActive('p89-future');
          if (overlay) {
            overlay.removeAttribute('data-slide-triggered'); // Reset slide state
          }
        } else if (scrollProgress > 0 && overlay && !overlay.hasAttribute('data-slide-triggered')) {
          // Start sliding immediately when phase 9 begins (synchronized with cube)
          overlay.setAttribute('data-slide-triggered', 'true');
          overlay.classList.remove('active');
          const H = (overlayViewport && overlayViewport.clientHeight) ? overlayViewport.clientHeight : 600;
          gsap.to(overlay, { 
            duration: 2.0, // Match cube movement timing
            y: -H, 
            ease: 'power2.out', 
            onComplete: () => { 
              overlay.style.visibility = 'hidden'; 
            }
          });
        }
        
        // Handle finale columns entrance - only animate once
        const finaleColumns = document.getElementById('finaleColumns');
        if (finaleColumns) {
          finaleColumns.style.display = 'flex';
          
          if (scrollProgress < 0.4) {
            // Keep columns hidden and below viewport before 40%
            if (!finaleColumns.hasAttribute('data-slide-state') || finaleColumns.getAttribute('data-slide-state') !== 'hidden') {
              finaleColumns.setAttribute('data-slide-state', 'hidden');
              gsap.set(finaleColumns, { y: window.innerHeight, visibility: 'hidden' });
            }
          } else if (scrollProgress >= 0.4 && finaleColumns.getAttribute('data-slide-state') !== 'animated') {
            // Start sliding in columns at 40% - animate only once
            finaleColumns.setAttribute('data-slide-state', 'animated');
            gsap.set(finaleColumns, { y: window.innerHeight, visibility: 'visible' });
            gsap.to(finaleColumns, { 
              duration: 1.8, 
              y: 0, 
              ease: 'power2.out'
            });
          }
        }
        
        // NOTE: Cube sliding is handled in applyPhases function using proper Three.js system
        // Both cube and text now start moving at scrollProgress > 0 (perfect synchronization)
      }
      if (p < 8) {
        // Hide finale columns when not in phase 8 or 9, and reset animation state
        const finaleColumns = document.getElementById('finaleColumns');
        if (finaleColumns) {
          finaleColumns.style.display = 'none';
          finaleColumns.removeAttribute('data-slide-state'); // Reset animation state for re-entry
          gsap.killTweensOf(finaleColumns); // Kill any ongoing animations
        }
        
        // Reset "The Future, Ready Today" text state for reverse scrolling
        const overlay = document.querySelector('.phase-text-block[data-key="p89-future"]');
        if (overlay) {
          gsap.killTweensOf(overlay); // Kill any ongoing animations
          overlay.style.visibility = 'visible';
          overlay.style.display = 'block';
          gsap.set(overlay, { y: 0 }); // Reset position
          overlay.removeAttribute('data-slide-triggered'); // Reset slide state
          // Force remove active class so setActive can add it properly in phase 8
          overlay.classList.remove('active');
        }
      }
      if (p === 8) {
        // Ensure finale columns are hidden in phase 8 and text is properly shown
        const finaleColumns = document.getElementById('finaleColumns');
        if (finaleColumns) {
          finaleColumns.style.display = 'none';
          finaleColumns.removeAttribute('data-slide-state');
        }
        
        // Ensure text is ready to be shown in phase 8
        const overlay = document.querySelector('.phase-text-block[data-key="p89-future"]');
        if (overlay) {
          overlay.removeAttribute('data-slide-triggered');
          overlay.style.visibility = 'visible';
          gsap.set(overlay, { y: 0 });
        }
      }
    }

    // ===== Animation per phase =====
    let lastPhaseId = null;
    function applyPhases(g) {
      const phase = getPhase(g);
      inInteractivePhase = (phase.id === 1 || phase.id === 9);
      if (lastPhaseId !== phase.id) {
        if (phase.id === 2) phase2Prepared = false; // re-anchor from current Phase 1 end on entry
        if (phase.id === 3) phase3Prepared = false; // re-anchor from current Phase 2 end on entry
        if (phase.id === 4) phase4Prepared = false; // re-anchor from current Phase 3 end on entry
        if (phase.id === 5) phase5Prepared = false;
        if (phase.id === 6) phase6Prepared = false;
        if (phase.id === 7) phase7Prepared = false;
        if (phase.id === 8) phase8Prepared = false;
        lastPhaseId = phase.id;
        try { window.parent && window.parent.postMessage({ type: 'RUBIKS_PHASE', id: phase.id, label: phase.label }, '*'); } catch (_) {}
      }
      const label = phase.label;
      if (phaseLabelEl) phaseLabelEl.textContent = label;
      if (progressEl) progressEl.textContent = (g * 100).toFixed(1) + '%';
      // Smooth bloom ramp during glow phases and enable only in >= Phase 8
      const tGlow = phase.id < 8 ? 0 : easeInOut(phaseProgress(g, PHASES[7].start, PHASES[7].end));
      bloomEnabled = (phase.id >= 8);
      if (bloomEnabled) {
  bloomPass.enabled = true;
  // Reduced bloom strength for less glow bleed
  bloomPass.strength = THREE.MathUtils.lerp(0.0, 0.18, tGlow);
      } else {
        bloomPass.enabled = false;
        bloomPass.strength = 0.0;
      }

      // Background handling with smooth tint darkening and video fade
      const bgVid = document.querySelector('.bg-video');
      // Compute darkness progress across phases 6 -> 7
      const p6 = PHASES[5], p7 = PHASES[6];
      const darkT = THREE.MathUtils.clamp((g - p6.start) / Math.max(1e-6, (p7.end - p6.start)), 0, 1);
      if (bgTintEl) {
        const base = { r: 10, g: 15, b: 28 };
        const r = Math.round(base.r * (1 - darkT));
        const gg = Math.round(base.g * (1 - darkT));
        const b = Math.round(base.b * (1 - darkT));
        const a = THREE.MathUtils.lerp(0.64, 1.0, easeInOut(darkT));
        bgTintEl.style.background = `rgba(${r},${gg},${b},${a})`;
      }
      if (phase.id >= 8) {
        const t8 = easeInOut(phaseProgress(g, PHASES[7].start, PHASES[7].end));
        if (bgVid) { bgVid.style.opacity = (1 - t8).toFixed(3); bgVid.style.display = t8 > 0.99 ? 'none' : ''; }
        document.documentElement.style.background = '#000000';
        document.body.style.background = '#000000';
        if (renderer.setClearAlpha) renderer.setClearAlpha(1);
        renderer.setClearColor(0x000000, 1);
        renderPass.clearAlpha = 1.0;
      } else {
        if (bgVid) { bgVid.style.opacity = '1'; bgVid.style.display = ''; }
        document.documentElement.style.background = 'transparent';
        document.body.style.background = 'transparent';
        if (renderer.setClearAlpha) renderer.setClearAlpha(0);
        renderer.setClearColor(0x000000, 0);
        renderPass.clearAlpha = 0.0;
      }

      // Default visibility
      if (mouseLabelEl) mouseLabelEl.style.display = 'none';

      // Base transforms reset
      // Keep root rotation gentle toward targetRot only in Phase 0 and 9

      // Phase 1 â€” Idle / Mouse Rotation
      if (phase.id === 1) {
        // Set initial rotation for front-facing cube only once per Phase 1 entry
        /*
        if (typeof phase1InitialRotationSet === 'undefined' || lastPhaseId !== 1) {
          root.rotation.set(-Math.PI/12, -Math.PI/4, 0); // Tilt top and turn front
          phase1InitialRotationSet = true;
        }
        */
        const t = phaseProgress(g, phase.start, phase.end);
        if (mouseLabelEl) mouseLabelEl.style.display = 'none';
        largeGroup.visible = true; miniGroup.visible = false;

        // Scroll-driven scale from 3.0x -> 1.5x across first 3 sections
        const introT = firstThreeScrollT();
        const targetScale = THREE.MathUtils.lerp(INTRO_START_SCALE, PHASE1_INITIAL_SCALE, easeInOut(introT));

        // deterministic positions/colors every frame for reversible scroll
        largePieces.forEach((p, i) => {
          // Smoothly settle back to Phase 1 initial positions to avoid snapping on reverse
          const targetPos = initialLargePositions[i];
          p.position.lerp(targetPos, 0.25);
          if (p.material) {
            if (Array.isArray(p.material)) {
              p.material.forEach(m => { if (m){ m.transparent=false; m.opacity=1.0; m.depthWrite=true; }});
            } else {
              // Do not override color
              p.material.transparent = false;
              p.material.opacity = 1.0;
              p.material.depthWrite = true;
            }
          }
          // reset edges opacity/transparent
          p.traverse(o => {
            if (o.isLineSegments && o.material) {
              o.material.transparent = false;
              o.material.opacity = 1.0;
              o.material.depthWrite = true;
            }
            if (o.userData && o.userData.sticker && o.material) {
              o.material.transparent = false;
              o.material.opacity = 1.0;
              o.material.depthWrite = true;
            }
          });
          p.scale.lerp(new THREE.Vector3(1,1,1), 0.25);
        });

        largeGroup.scale.setScalar(targetScale);
        if (!isDragging) {
          // gentle float & rotation
          const tAuto = perf.now * 0.001;
          const floatY = Math.sin(tAuto * 0.8) * (PHASE1_SPAN * 0.015);
          root.position.y = THREE.MathUtils.damp(root.position.y, floatY, 3, delta);
          const rx = Math.sin(tAuto * 0.15) * 0.15 + 1;
          const ry = Math.cos(tAuto * 0.12) * 0.22 + 3;
          root.rotation.x = THREE.MathUtils.damp(root.rotation.x, rx, 4, delta);
          root.rotation.y = THREE.MathUtils.damp(root.rotation.y, ry, 4, delta);
        }

        // strict handover: snapshot end-state once when phase completes
        if (!phase1AnchorSet && g >= phase.end - 1e-6) {
          phase1Anchor.largePositions = largePieces.map(p => p.position.clone());
          phase1Anchor.largeScale = largeGroup.scale.x;
          phase1Anchor.rootRotation = new THREE.Vector2(root.rotation.x, root.rotation.y);
          phase1AnchorSet = true;
        }
      }

      // Phase 2 â€” First Dismantle / Dramatic Cloud
      if (phase.id === 2) {
        const t = easeInOut(phaseProgress(g, phase.start, phase.end));
        largeGroup.visible = true; miniGroup.visible = false;

        // Prepare on each entry using strict handover from current Phase 1 end
        if (!phase2Prepared) {
          phase2FromPositions = largePieces.map(p => p.position.clone());
          
          // if (phase1Anchor && phase1Anchor.rootRotation)
//          root.rotation.x = phase1Anchor.rootRotation.x;
//          root.rotation.y = phase1Anchor.rootRotation.y;
          // else {
          //   root.rotation.set(0, 0, 0);
          // }
          
          phase2Prepared = true;
        }

        const R = PHASE2_RADIUS;

        largePieces.forEach((p, i) => {
          const dir = largeDirs[i];
          const target = dir.clone().multiplyScalar(R);
          const from = phase2FromPositions[i] || p.position.clone();
          p.position.copy(from.clone().lerp(target, t));
          if (p.material) {
            if (Array.isArray(p.material)) {
              p.material.forEach(m => { if (m){ m.transparent=false; m.opacity=1.0; m.depthWrite=true; }});
            } else {
              // Do not override color
              p.material.transparent = false;
              p.material.opacity = 1.0;
              p.material.depthWrite = true;
            }
          }
          p.traverse(o => {
            if (o.isLineSegments && o.material) {
              o.material.transparent = false;
              o.material.opacity = 1.0;
              o.material.depthWrite = true;
            }
            if (o.userData && o.userData.sticker && o.material) {
              o.material.transparent = false;
              o.material.opacity = 1.0;
              o.material.depthWrite = true;
            }
          });
        });
        // capture end-state positions for use as Phase 3 base (consistent anchor)
        if (t >= 0.999) {
          phase2EndPositions = largePieces.map(p => p.position.clone());
        }
      }

      // Phase 3 â€” Hovering with slow random rotations (no position drift)
      if (phase.id === 3) {
        const t = phaseProgress(g, phase.start, phase.end); // not used to change base positions
        largeGroup.visible = true; miniGroup.visible = false;

        // Keep stickers fully opaque in Phase 3
        largePieces.forEach((p)=>{
          p.traverse(o=>{
            if (o.userData && o.userData.sticker && o.material){
              o.material.transparent = false;
              o.material.opacity = 1.0;
              o.material.depthWrite = true;
            }
          });
        });

        // Strict handover: anchor from Phase 2 end on entry and set random axes/speeds
        if (!phase3Prepared) {
          // If available, use exact Phase 2 end snapshot; otherwise fallback to current
          phase3FromPositions = (phase2EndPositions.length ? phase2EndPositions : largePieces.map(p => p.position.clone())).map(v=>v.clone());
          phase3FromScale = largeGroup.scale.x;
          phase3BaseRotations = largePieces.map(p => p.quaternion.clone());
          phase3Axes = largePieces.map(() => new THREE.Vector3(Math.random()*2-1, Math.random()*2-1, Math.random()*2-1).normalize());
          phase3Speeds = largePieces.map(() => THREE.MathUtils.lerp(0.05, 0.15, Math.random()));
          phase3StartTime = perf.now * 0.001;
          phase3Prepared = true;
        }

        const time = Math.max(0, (perf.now * 0.001) - phase3StartTime);
        const t3 = easeInOut(phaseProgress(g, PHASES[2].start, PHASES[2].end));
        largePieces.forEach((p, i) => {
          // Position: base + gentle vertical hover
          const base = phase3FromPositions[i] || p.position.clone();
          const hover = Math.sin(time * PHASE3_HOVER_FREQ + i * 0.21) * PHASE3_HOVER_AMP;
          p.position.set(base.x, base.y + hover, base.z);
          if (p.material) {
            if (Array.isArray(p.material)) {
              p.material.forEach(m => { if (m){ m.transparent=true; m.opacity=THREE.MathUtils.lerp(1.0, 0.8, t3); }});
            } else {
              // Do not override color
              p.material.transparent = true;
              p.material.opacity = THREE.MathUtils.lerp(1.0, 0.8, t3);
            }
          }

          // Rotation: base rotation * axis-angle(time * speed)
          const axis = phase3Axes[i];
          const speed = phase3Speeds[i];
          const q = new THREE.Quaternion().setFromAxisAngle(axis, time * speed);
          p.quaternion.copy(phase3BaseRotations[i]).multiply(q);
        });

        // Keep group scale unchanged in Phase 3
        largeGroup.scale.setScalar(phase3FromScale);
      }

      // Phase 4 â€” Rubik Transform (reveal 729 mini cubes)
      // Large cubes shrink and fade out while mini cubes grow from within to form the inner Rubik's cube
      if (phase.id === 4) {
        const t = easeInOut(phaseProgress(g, phase.start, phase.end));
        largeGroup.visible = true; miniGroup.visible = true; frameGroup.visible = false; coreSphere.visible = false; if (typeof coreLight !== 'undefined') coreLight.visible = false;

        // Prepare anchors once from Phase 3 rendered state (positions include current hover)
        // This guarantees minis originate exactly where the visible large cubes are at transition time
        if (!phase4Prepared) {
          phase4FromLargePositions = largePieces.map(p => p.getWorldPosition(new THREE.Vector3()));
          phase4FromLargeQuats = largePieces.map(p => p.getWorldQuaternion(new THREE.Quaternion()));
          // Reset minis to a clean baseline (no elongation/rotation from later phases)
          miniCubes.forEach((m) => {
            m.quaternion.identity();
            m.rotation.set(0,0,0);
            const s0 = (m.userData && typeof m.userData.initialScale === 'number') ? m.userData.initialScale : 0.0001;
            m.scale.setScalar(s0);
          });
          phase4Prepared = true;
        }

        // Fade large pieces out while minis grow into oriented local grids around each large piece's current pose
        largePieces.forEach((p) => {
          if (p.material) {
            if (Array.isArray(p.material)) {
              p.material.forEach(m => { if (!m) return; m.transparent = true; m.opacity = THREE.MathUtils.lerp(0.6, 0.0, t); m.depthWrite = false; });
            } else {
              p.material.transparent = true;
              p.material.opacity = THREE.MathUtils.lerp(0.6, 0.0, t);
              p.material.depthWrite = false;
            }
          }
          p.traverse(o => {
            if (o.isLineSegments && o.material) {
              o.material.transparent = true;
              o.material.opacity = THREE.MathUtils.lerp(0.5, 0.0, t);
              o.material.depthWrite = false;
            }
            if (o.userData && o.userData.sticker && o.material) {
              o.material.transparent = true;
              o.material.opacity = THREE.MathUtils.lerp(1.0, 0.0, t);
              o.material.depthWrite = false;
            }
          });
          p.scale.setScalar(Math.max(0.001, 1 - t));
        });

        miniCubes.forEach((m) => {
          const ownerIndex = (m.userData && typeof m.userData.ownerIndex === 'number') ? m.userData.ownerIndex : 0;
          const lp = largePieces[ownerIndex];
          const origin = phase4FromLargePositions[ownerIndex] || (lp ? lp.getWorldPosition(new THREE.Vector3()) : new THREE.Vector3());
          const quat = phase4FromLargeQuats[ownerIndex] || (lp ? lp.getWorldQuaternion(new THREE.Quaternion()) : new THREE.Quaternion());
          const local = m.userData.local || new THREE.Vector3();
          const offset = new THREE.Vector3(local.x * MINI_STEP, local.y * MINI_STEP, local.z * MINI_STEP).applyQuaternion(quat);
          const target = origin.clone().add(offset);
          const pos = origin.clone().lerp(target, t);
          m.position.copy(pos);
          const s = lerp(m.userData.initialScale, 1, t);
          m.scale.setScalar(s);
        });
        // Ensure the large cubes fully disappear at the end of Phase 4
        largeGroup.visible = t < 0.98;
        // Snapshot end-state positions for reversible anchoring
        if (t >= 0.999) {
          phase4EndPositions = miniCubes.map(m => m.getWorldPosition(new THREE.Vector3()));
        }
      }

      // Phase 5 â€” Expand to 43.3% (retain Phase 4 color/state)
      if (phase.id === 5) {
        const t5 = easeInOut(phaseProgress(g, phase.start, phase.end));
        largeGroup.visible = false; miniGroup.visible = true; frameGroup.visible = false; coreSphere.visible = false; if (typeof coreLight !== 'undefined') coreLight.visible = false;
        if (!phase5Prepared) {
          // Anchor deterministically from Phase 4 end for reversible scroll
          phase5StartPositions = (phase4EndPositions.length ? phase4EndPositions : miniCubes.map(m => m.getWorldPosition(new THREE.Vector3())));
          phase5Dirs = miniCubes.map((m) => {
            const b = m.userData.base || new THREE.Vector3();
            const v = new THREE.Vector3(b.x, b.y, b.z).normalize();
            if (v.lengthSq() === 0) v.set(Math.random()*2-1, Math.random()*2-1, Math.random()*2-1).normalize();
            return v;
          });
          phase5Prepared = true;
        }
        const R = cloudRadiusForMini();
        const up = new THREE.Vector3(0,1,0);
        miniCubes.forEach((m, idx) => {
          const start = phase5StartPositions[idx];
          const dir = phase5Dirs[idx];
          const cloud = dir.clone().multiplyScalar(R);
          const pos = start.clone().lerp(cloud, 0.433 * t5);
          // Tiny hover for life, but largely static
          const hover = Math.sin(perf.now * 0.001 + idx * 0.13) * 0.02;
          m.position.lerp(pos.clone().addScaledVector(up, hover), 0.5);
        });
        if (t5 >= 0.999) {
          phase5EndPositions = miniCubes.map(m => m.getWorldPosition(new THREE.Vector3()));
        }
      }

      // ===== PHASE 6 â€” POPCORN RECOLORING =====
      /**
       * The signature "popcorn" animation where 729 mini-cubes recolor individually
       * Each cube changes from cyan (0x00f0ff) to purple (0xC084FC) at different times
       * Creates a wave-like effect as cubes "pop" to their new color
       *
       * TIMING SYSTEM:
       * - First 15 cubes activate slowly (0.02 per cube) for gentle start
       * - Remaining cubes accelerate with quadratic curve for dramatic finish
       * - Each cube has 0.08 progress window for smooth color transition
       *
       * VISUAL EFFECTS:
       * - MeshBasicMaterial: Uses transparency for glow-like effect
       * - MeshStandardMaterial: Uses emissive properties for true glow
       * - Maintains positions with subtle hover animation
       * - Dark navy edges remain consistent throughout
       */
      if (phase.id === 6) {
        const t6 = easeInOut(phaseProgress(g, phase.start, phase.end));
        largeGroup.visible = false; miniGroup.visible = true;
        frameGroup.visible = false; coreSphere.visible = false;
        if (typeof coreLight !== 'undefined') coreLight.visible = false;

        // ===== PHASE 6 INITIALIZATION =====
        if (!phase6Prepared) {
          // Anchor positions from Phase 5 end-state for smooth transition
          phase6AnchorPositions = (phase5EndPositions.length ?
            phase5EndPositions : miniCubes.map(m => m.getWorldPosition(new THREE.Vector3())));

          // ===== RANDOM ACTIVATION ORDER =====
          // Create shuffled order for popcorn effect (not sequential)
          phase6ColorOrder = [...miniCubes.keys()]; // [0,1,2,...,728]
          // Fisher-Yates shuffle for random order
          for (let i = phase6ColorOrder.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [phase6ColorOrder[i], phase6ColorOrder[j]] = [phase6ColorOrder[j], phase6ColorOrder[i]];
          }

          // ===== ACTIVATION TIMING SYSTEM =====
          // Creates staggered activation for popcorn effect
          const N = miniCubes.length; // 729 cubes
          const first = 15; // First 15 cubes activate slowly
          phase6Activation = new Array(N).fill(0);

          for (let rank = 0; rank < N; rank++) {
            const idx = phase6ColorOrder[rank]; // Which cube activates at this rank
            if (rank < first) {
              // Slow start: first 15 cubes spread evenly
              phase6Activation[idx] = Math.min(1, rank * 0.02); // 0, 0.02, 0.04, ..., ~0.28
            } else {
              // Acceleration: quadratic curve for dramatic finish
              const r = (rank - first) / (N - first); // 0 to 1 for remaining cubes
              phase6Activation[idx] = 0.28 + r * r * (0.92 - 0.28); // 0.28 to 0.92
            }
          }

          // Store end positions for Phase 7 handover
          phase6EndPositions = phase6AnchorPositions.map(v => v.clone());
          phase6Prepared = true;
        }

        // ===== COLOR TRANSITION SYSTEM =====
        const fromColor = new THREE.Color(0x0066CC); // Blue (matches initial mini-cube color)
  // const toColor = new THREE.Color(0xC084FC);   // Purple (original)
  const toColor = new THREE.Color(0x6B21A8);   // Darker purple
        const up = new THREE.Vector3(0,1,0); // Up vector for hover

        miniCubes.forEach((m, idx) => {
          // ===== POSITION MAINTENANCE =====
          // Hold Phase 5 positions with subtle hover
          const pos = phase6AnchorPositions[idx];
          const hover = Math.sin(perf.now * 0.001 + idx * 0.13) * 0.015; // Unique hover per cube
          m.position.lerp(pos.clone().addScaledVector(up, hover), 0.6);

          // ===== INDIVIDUAL CUBE TIMING =====
          const a = phase6Activation[idx]; // When this cube starts recoloring
          const p = clamp((t6 - a) / 0.08, 0, 1); // 0.08 = transition window duration

          // ===== MATERIAL RECOLORING =====
          m.traverse(o => {
            if (o.isMesh && o.material) {
              const mats = Array.isArray(o.material) ? o.material : [o.material];
              mats.forEach(mat => {
                if (mat && mat.color) {
                  // ===== COLOR INTERPOLATION =====
                  mat.color = mat.color || new THREE.Color();
                  mat.color.lerpColors(fromColor, toColor, p); // Smooth color transition

                  // ===== GLOW EFFECT SYSTEM =====
                  /*
                  // Different approaches for different material types
                  if (!('emissive' in mat)) {
                    // MeshBasicMaterial: Use transparency for glow-like effect
                    mat.transparent = true;
                    mat.opacity = THREE.MathUtils.lerp(1.0, 0.8, p); // Slight fade for depth
                  }
                  if ('emissive' in mat) {
                    // MeshStandardMaterial: Use emissive properties for true glow
                    const emissiveTarget = new THREE.Color(0xC084FC); // Purple glow
                    mat.emissive = mat.emissive || new THREE.Color(0x000000);
                    mat.emissive.lerpColors(new THREE.Color(0x000000), emissiveTarget, p);
                    mat.emissiveIntensity = THREE.MathUtils.lerp(0.0, 0.75, p); // Glow intensity
                  }
                  */
                }
              });
            }
            // ===== EDGE COLOR CHANGE =====
            // Change edges to grey for purple cubes
            if (o.isLineSegments && o.material) {
              o.material.color.set(0x808080); // Grey color for purple cube edges
            }
          });
        });
      }

      // Phase 7 â€” Dance (swirl/orbit/hover)
      if (phase.id === 7) {
        const t7 = easeInOut(phaseProgress(g, phase.start, phase.end));
        largeGroup.visible = false; miniGroup.visible = true; frameGroup.visible = false; coreSphere.visible = false; if (typeof coreLight !== 'undefined') coreLight.visible = false;
        if (!phase7Prepared) {
          // Anchor from Phase 6 end-state for reversible scroll
          phase7StartPositions = (phase6EndPositions.length ? phase6EndPositions : miniCubes.map(m => m.getWorldPosition(new THREE.Vector3())));
          phase7Dirs = miniCubes.map((m) => {
            const b = m.userData.base || new THREE.Vector3();
            const v = new THREE.Vector3(b.x, b.y, b.z).normalize();
            if (v.lengthSq() === 0) v.set(Math.random()*2-1, Math.random()*2-1, Math.random()*2-1).normalize();
            return v;
          });
          phase7Swirl = miniCubes.map(() => Math.random() * Math.PI * 2);
          phase7Prepared = true;
        }
        const R = cloudRadiusForMini();
        const up = new THREE.Vector3(0,1,0);
        miniCubes.forEach((m, idx) => {
          const base = phase7StartPositions[idx];
          const dir = phase7Dirs[idx];
          const anchor = dir.clone().multiplyScalar(R * 0.95);
          const baseToAnchor = base.clone().lerp(anchor, t7);
          const angle = (perf.now * 0.001) + phase7Swirl[idx];
          const tangent = dir.clone().cross(up).normalize();
          const binorm = dir.clone().cross(tangent).normalize();
          const swirlRadius = MINI_STEP * 2.0 * t7; // start with no swirl and grow radius
          const swirlOffset = tangent.multiplyScalar(Math.cos(angle) * swirlRadius).add(binorm.multiplyScalar(Math.sin(angle) * swirlRadius));
          const pos = baseToAnchor.clone().add(swirlOffset);
          const hover = Math.sin(perf.now * 0.0012 + idx * 0.17) * 0.06 * (0.5 + 0.5 * t7);
          m.position.lerp(pos.clone().addScaledVector(up, hover), 0.6);
          m.rotation.x += 0.004 * t7;
          m.rotation.y -= 0.003 * t7;
        });
      }

      // Phase 8 â€” Morph to final spherical sculpture (full black bg, glow, final size matches intro 3.0x)
      if (phase.id === 8) {
        const t8 = easeInOut(phaseProgress(g, phase.start, phase.end));
        largeGroup.visible = false; miniGroup.visible = true; frameGroup.visible = true; coreSphere.visible = true; coreLight.visible = true;
        // Final size should match intro oversized cube (3.0x vs Phase 1's 1.5x) with deterministic scaling
        {
          const FINAL_SCALE = INTRO_START_SCALE / PHASE1_INITIAL_SCALE; // 3.0 / 1.5 = 2.0
          root.scale.setScalar(THREE.MathUtils.lerp(1.0, FINAL_SCALE, t8));
        }
        // Enable subtle glow already in Phase 8 to avoid pop in Phase 9
        if (beamMat && 'emissive' in beamMat) {
          beamMat.emissive = new THREE.Color(0xFFFFFF); // White color for frame
          beamMat.emissiveIntensity = 0.6 + 0.3 * t8;
        }
        if (coreSphere.material && 'emissive' in coreSphere.material) {
          coreSphere.material.emissive = new THREE.Color(0xBC9D00); // Soft gold color for core
          coreSphere.material.emissiveIntensity = 0.8 + 0.4 * t8;
        }
        if (!phase8Prepared) {
          phase8StartPositions = miniCubes.map(m => m.getWorldPosition(new THREE.Vector3()));
          phase8Prepared = true;
        }
        miniCubes.forEach((m, idx) => {
          const from = phase8StartPositions[idx];
          const to = sculpturePos[idx];
          const pos = from.clone().lerp(to, t8);
          m.position.lerp(pos, 0.6);
          // orient toward normal and elongate along it
          const targetQ = sculptureQuat[idx];
          m.quaternion.slerp(targetQ, 0.6 * t8);
          const targetS = sculptureScale[idx];
          m.scale.lerp(targetS, 0.4);
          m.traverse(o => {
            if (o.isMesh && o.material && 'emissiveIntensity' in o.material) {
              o.material.emissive = new THREE.Color(0x4F049A); // deep purple
              o.material.emissiveIntensity = 0.2 + 0.2 * t8;
            }
          });
        });
      }

      // Phase 9 â€” Final Formation (purple fills, mouse rotation enabled), show frame + core, full black bg, final size matches intro 3.0x
      if (phase.id === 9) {
        const t = easeInOut(phaseProgress(g, phase.start, phase.end));
        largeGroup.visible = false; miniGroup.visible = true; frameGroup.visible = true; coreSphere.visible = true; coreLight.visible = true;
        if (mouseLabelEl) mouseLabelEl.style.display = 'none';

        // Move cube upward in sync with scroll progress in phase 9
        frameGroup.position.y = 0; coreSphere.position.y = 0;
        const phase9 = PHASES[8];
        const phase9Start = phase9.start;
        const phase9End = phase9.end;
        let scrollOutProgress = 0;
        if (g >= phase9Start && g <= phase9End) {
          scrollOutProgress = clamp((g - phase9Start) / (phase9End - phase9Start), 0, 1);
        }
        if (!isDragging) {
          const tAuto9 = perf.now * 0.001;
          const rootFloat = Math.sin(tAuto9 * 0.8) * (PHASE1_SPAN * 0.02);
          // Move cube up by up to 12 units to completely leave view
          const maxOffset = PHASE1_SPAN * 8.0; // significantly increase to ensure cube completely leaves view
          const scrollY = scrollOutProgress * maxOffset;
          root.position.y = rootFloat + scrollY;
          const rx9 = Math.sin(tAuto9 * 0.15) * 0.12;
          const ry9 = Math.cos(tAuto9 * 0.12) * 0.20;
          root.rotation.x = THREE.MathUtils.damp(root.rotation.x, rx9, 4, delta);
          root.rotation.y = THREE.MathUtils.damp(root.rotation.y, ry9, 4, delta);
        }
        // Final size should match intro oversized cube (3.0x vs Phase 1's 1.5x) with deterministic scaling
        {
          const FINAL_SCALE = INTRO_START_SCALE / PHASE1_INITIAL_SCALE;
          root.scale.setScalar(FINAL_SCALE);
        }
        coreSphere.scale.setScalar(1.0);
        coreLight.distance = PHASE1_SPAN * 4.0;
        coreLight.intensity = 3.2;
        // Make frame and core sphere glow (emissive) in final phase
        if (beamMat && 'emissive' in beamMat) {
          beamMat.emissive = new THREE.Color(0xFFFFFF); // White color for frame
          beamMat.emissiveIntensity = 1.0;
        }
        if (coreSphere.material && 'emissive' in coreSphere.material) {
          coreSphere.material.emissive = new THREE.Color(0xBC9D00); // Soft gold color for core
          // Reduced emissive intensity for less glow
          coreSphere.material.emissiveIntensity = 0.9;
        }
        miniCubes.forEach((m, idx) => {
          const ft = sculpturePos[idx];
          m.position.lerp(ft, 0.2);
          m.quaternion.slerp(sculptureQuat[idx], 0.15);
          m.scale.lerp(sculptureScale[idx], 0.15);
          
          m.traverse(o => {
            if (o.isMesh && o.material && 'emissiveIntensity' in o.material) {
              o.material.emissive = new THREE.Color(0x4F049A); // purple glow
              o.material.emissiveIntensity = 0.9;
            }
          });
          
        });
        // purple fills only
  // setCubeFillColor(miniGroup, 0xC084FC); // original: light purple
  // setCubeFillColor(miniGroup, 0x6B21A8); // previous: dark purple
  // setCubeFillColor(miniGroup, 0x4B0082); // previous: even darker purple
  setCubeFillColor(miniGroup, 0x500050); // final: vivid dark purple (#8A008A)
      } else if (phase.id === 4 || phase.id === 5) {
        // During transform and expand, match minis to blue color
        setCubeFillColor(miniGroup, 0x0066CC);
      } else if (phase.id === 6 || phase.id === 7 || phase.id === 8) {
        // Carry over per-cube colors from prior phase; no global override
      } else {
        // other phases: neutral fill while preserving white edges
        setCubeFillColor(miniGroup, 0x1f2937);
        miniCubes.forEach((m) => {
          m.traverse(o => {
            if (o.isMesh && o.material && 'emissiveIntensity' in o.material) {
              o.material.emissive = new THREE.Color(0x000000);
              o.material.emissiveIntensity = 0.0;
            }
          });
        });
        frameGroup.visible = false; coreSphere.visible = false; if (typeof coreLight !== 'undefined') coreLight.visible = false;
      }

      // Locking behavior: large pieces remain at their phase-end positions after Phase 2 completion (implicitly handled by continuous lerp to cloud target before transform)

      // Autonomous rotation in phases 1 and 9 is applied above; otherwise settle to neutral
      if (phase.id !== 1 && phase.id !== 9) {
        root.rotation.x = THREE.MathUtils.damp(root.rotation.x, 0, 2, delta);
        root.rotation.y = THREE.MathUtils.damp(root.rotation.y, 0, 2, delta);
        root.position.y = THREE.MathUtils.damp(root.position.y, 0, 3, delta);
      }

      // Restore orientations when not in Phase 3 to avoid residual rotation on reverse scroll
      if (phase.id !== 3 && phase3Prepared) {
        largePieces.forEach((p, i) => {
          if (phase3BaseRotations[i]) p.quaternion.copy(phase3BaseRotations[i]);
        });
      }

      // Metrics
      if (metricsEl) metricsEl.textContent = label;
      updateCoords(phase.id);
    }

    // ===== Resize =====
    function fitCameraToPhase1Bounds() {
      const scale = 1.5;
      const halfExtent = (STEP + LARGE_SIZE * 0.5) * scale;
      const fov = THREE.MathUtils.degToRad(camera.fov * 0.5);
      const rect = containerEl.getBoundingClientRect();
      const aspect = Math.max(0.0001, rect.width / Math.max(1, rect.height));
      const dVert = halfExtent / Math.tan(fov);
      const dHoriz = (halfExtent / aspect) / Math.tan(fov);
      let need = Math.max(dVert, dHoriz) * 1.8; // stronger margin to ensure full fit
      const current = camera.position.length();
      if (need < current) need = current; // never move closer than current distance
      const dir = camera.position.clone().normalize();
      camera.position.copy(dir.multiplyScalar(need));
      camera.lookAt(0, CAMERA_TARGET_Y, 0);
    }

    function layoutAndResize() {
      const headerEl = document.querySelector('header');
      const footerEl = document.querySelector('footer');
      const topInset = headerEl ? headerEl.offsetHeight : 0;
      const bottomInset = footerEl ? footerEl.offsetHeight : 0;
      containerEl.style.top = topInset + 'px';
      containerEl.style.bottom = bottomInset + 'px';

      const rect = containerEl.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(w, h, false);
      camera.aspect = w / h; camera.updateProjectionMatrix();
      composer.setSize(w, h);
      bloomPass.setSize(w, h);
      renderer.setViewport(0, 0, w, h);
      renderer.setScissorTest(false);
    }
    window.addEventListener('resize', layoutAndResize);
    layoutAndResize();
    try { window.parent && window.parent.postMessage({ type: 'RUBIKS_READY' }, '*'); } catch (_) {}

    // ===== MAIN ANIMATION LOOP =====
    /**
     * Core render loop handling progress calculation, phase application, and rendering
     * Runs at 60fps using requestAnimationFrame for smooth animation
     */

    const clock = new THREE.Clock();
    let delta = 0; // Time delta between frames
    let perf = { now: 0 }; // Performance tracking
    let lastBroadcastProgress = -1; // Last progress value sent to parent
    let introOffset = null; // Timeline offset for smooth intro transition

    /**
     * Main render function called each frame
     * Handles progress calculation, phase logic, and rendering
     */
    function render() {
      delta = clock.getDelta(); // Time since last frame
      perf.now = performance.now(); // Current timestamp

      const g = globalProgress(); // Get current scroll progress (0-1)

      // Broadcast progress to parent component (throttled)
      if (Math.abs(g - lastBroadcastProgress) > 0.001) {
        lastBroadcastProgress = g;
        try { window.parent && window.parent.postMessage({ type: 'RUBIKS_PROGRESS', value: g }, '*'); } catch (_) {}
      }

      // ===== PROGRESS CALCULATION =====
      let gPhase; // Phase-specific progress
      const introT = firstThreeScrollT(); // Intro scroll progress

      if (introT < 1 && externalProgress === null) {
        // During intro: Map first 3 sections to Phase 1 smoothly
        gPhase = THREE.MathUtils.lerp(PHASES[0].start, PHASES[0].end, easeInOut(introT));
        introOffset = null;
      } else {
        // After intro: Rebase timeline so scroll release = Phase 2 start
        if (introOffset === null) introOffset = g - PHASES[1].start;
        gPhase = clamp(g - introOffset, 0, 1);
      }

      // ===== VIEWPORT MANAGEMENT =====
      // Ensure clean rendering without artifacts
      const rect = containerEl.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      renderer.setViewport(0, 0, w, h);
      renderer.setScissorTest(false);

      // ===== ANIMATION APPLICATION =====
      // Option 1: Animate cube position upward in phase 9
      const phase9 = PHASES[8];
      const phase9Start = phase9.start;
      const phase9End = phase9.end;
      let scrollOutProgress = 0;
      if (gPhase >= phase9Start && gPhase <= phase9End && window.root) {
        scrollOutProgress = clamp((gPhase - phase9Start) / (phase9End - phase9Start), 0, 1);
        // Move root group up by up to 120% of viewport height (scaled to world units)
        const maxOffset = window.innerHeight * 1.2 * 0.02; // scale for world units
        window.root.position.y = scrollOutProgress * maxOffset;
      }
      applyPhases(gPhase); // Apply current phase animations

      // Update text overlays based on phase
      updateOverlayText(gPhase, introT);

      // ===== RENDERING =====
      // Use bloom composer if enabled, otherwise direct renderer
      if (bloomEnabled) composer.render(); else renderer.render(scene, camera);

      requestAnimationFrame(render); // Schedule next frame
    }

    // ===== ANIMATION INITIALIZATION =====
    render(); // Start the animation loop
    
    // Initialize navigation system with proper event handlers
    setTimeout(() => {
      initializeNavigation();
    }, 100);

    // ===== EXTERNAL COMMUNICATION =====
    // Notify parent component that animation is ready
    try { window.parent && window.parent.postMessage({ type: 'RUBIKS_READY' }, '*'); } catch (_) {}
  </script>
</body>
</html>